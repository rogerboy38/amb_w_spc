[
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.262649",
  "module": "amb_w_tds",
  "name": "animal_trial",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Animal Trial",
  "script": "pass",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.252149",
  "module": "amb_w_tds",
  "name": "Batch and Serial",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "# Auto-create barrel serials when Sub-Batch is submitted\r\n@frappe.whitelist()\r\ndef create_barrel_serials(batch_id, barrel_count=20):\r\n    batch = frappe.get_doc(\"Batch\", batch_id)\r\n    \r\n    if not batch.custom_is_sub_batch:\r\n        frappe.throw(\"Barrel serials can only be created for Sub-Batches!\")\r\n    \r\n    serials = []\r\n    for i in range(1, barrel_count + 1):\r\n        serial_no = f\"{batch.name}-{i:02d}\"  # Format: \"PARENT_BATCH-TRUCK_SEQ-BARREL_NO\"\r\n        \r\n        frappe.get_doc({\r\n            \"doctype\": \"Serial No\",\r\n            \"serial_no\": serial_no,\r\n            \"item_code\": batch.item,\r\n            \"batch_no\": batch.name,\r\n            \"status\": \"Active\"\r\n        }).insert()\r\n        \r\n        serials.append(serial_no)\r\n    \r\n    return serials\r\n\r\n# Hook to auto-trigger on Batch submit\r\ndef on_submit(doc, method):\r\n    if doc.custom_is_sub_batch:\r\n        create_barrel_serials(doc.name)",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.242489",
  "module": "amb_w_tds",
  "name": "batch_naming_amb_old",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "# Server Script: batch_naming_amb\r\nfrappe.get_doc({\r\n  \"doctype\": \"Server Script\",\r\n  #\"name\": \"batch_naming_amb\",\r\n  \"script_type\": \"DocType Event\",\r\n  \"doctype_event\": \"Before Save\",\r\n  \"reference_doctype\": \"Batch AMB\",\r\n  \"script\": \"\"\"\r\nif not doc.name and doc.tds_item:\r\n    # Extract first 4 chars of Item Code\r\n    item_prefix = doc.tds_item[:4]\r\n    year = frappe.utils.getdate().strftime(\"%y\")\r\n    plant_code = frappe.db.get_value(\"Production Plant\", doc.plant, \"plant_code\") or \"0\"\r\n    \r\n    # Get last batch for this item/year/plant\r\n    last_batch = frappe.get_all(\"Batch AMB\",\r\n        filters={\r\n            \"tds_item\": doc.tds_item,\r\n            \"creation\": (\">=\", f\"20{year}-01-01\"),\r\n            \"name\": (\"like\", f\"{item_prefix}%{year}{plant_code}\")\r\n        },\r\n        fields=[\"name\"],\r\n        order_by=\"creation DESC\",\r\n        limit=1\r\n    )\r\n    \r\n    # Calculate next consecutive number\r\n    if last_batch:\r\n        last_id = last_batch[0].name\r\n        consecutive = int(last_id[4:7]) + 1  # Positions 5-7\r\n    else:\r\n        consecutive = 1\r\n    \r\n    # Format: ItemPrefix(4) + Consecutive(3) + Year(2) + Plant(1)\r\n    doc.name = f\"{item_prefix}{consecutive:03d}{year}{plant_code}\"\r\n    frappe.msgprint(f\"Generated Batch ID: {doc.name}\")  # Debug\r\n\"\"\"\r\n}).insert()",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.716864",
  "module": "amb_w_tds",
  "name": "Batch L1",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "# Run this once in Console (Developer Tools)\r\nif not frappe.db.exists(\"Server Script\", \"batch_naming_amb\"):\r\n    frappe.get_doc({\r\n        \"doctype\": \"Server Script\",\r\n        \"name\": \"batch_naming_amb\",\r\n        \"script_type\": \"DocType Event\",\r\n        \"doctype_event\": \"Before Save\",\r\n        \"reference_doctype\": \"Batch AMB\",\r\n        \"script\": \"\"\"\r\nif not doc.name:\r\n    year = frappe.utils.getdate().strftime(\"%y\")\r\n    \r\n    # Get last batch for current year\r\n    last_batch = frappe.get_all(\"Batch AMB\",\r\n        filters={\"creation\": (\">=\", f\"{year}-01-01\")},\r\n        fields=[\"name\"],\r\n        order_by=\"creation DESC\",\r\n        limit=1\r\n    )\r\n    \r\n    # Calculate next consecutive number\r\n    if last_batch and last_batch[0].name.startswith(f\"AMB-{year}-\"):\r\n        last_num = int(last_batch[0].name.split(\"-\")[-1])\r\n        consecutive = last_num + 1\r\n    else:\r\n        consecutive = 1\r\n    \r\n    # Format: AMB-YY-001\r\n    doc.name = f\"AMB-{year}-{str(consecutive).zfill(3)}\"\r\n    doc.consecutive_number = consecutive\r\n\"\"\"\r\n    }).insert()\r\n#import frappe\r\n\r\n#@frappe.whitelist()\r\ndef get_running_batch_announcements():\r\n    \"\"\"Get running batch announcements for navbar widget\"\"\"\r\n    try:\r\n        # Check if Batch AMB doctype exists\r\n        if not frappe.db.exists(\"DocType\", \"Batch AMB\"):\r\n            return {\"success\": False, \"message\": \"Batch AMB doctype not found\"}\r\n        \r\n        # Get running batches\r\n        running_batches = frappe.get_all(\"Batch AMB\",\r\n            filters={\"status\": \"Running\"},\r\n            fields=[\"name\", \"title\", \"batch_id\", \"production_status\", \"priority\", \"start_time\"]\r\n        )\r\n        \r\n        announcements = []\r\n        for batch in running_batches:\r\n            announcements.append({\r\n                \"title\": batch.title or batch.name,\r\n                \"content\": f\"🔧 Batch: {batch.batch_id or 'N/A'}\\n⏱ Status: {batch.production_status or 'Running'}\\n🕐 Started: {batch.start_time or 'N/A'}\",\r\n                \"priority\": batch.priority or \"medium\"\r\n            })\r\n        \r\n        return {\r\n            \"success\": True,\r\n            \"announcements\": announcements,\r\n            \"count\": len(announcements)\r\n        }\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(\"Batch Announcements Error\", str(e))\r\n        return {\"success\": False, \"message\": str(e)}",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.232626",
  "module": "amb_w_tds",
  "name": "batch_naming_amb",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Order",
  "script": "# Server Script: batch_naming_amb\r\nfrappe.get_doc({\r\n  \"doctype\": \"Sales Order\",\r\n  \"name\": \"batch_naming_amb\",\r\n  \"script_type\": \"DocType Event\",\r\n  \"doctype_event\": \"Before Save\",\r\n  \"reference_doctype\": \"Batch\",\r\n  \"script\": \"\"\"\r\nif not doc.name and doc.tds_item:\r\n    # Extract first 4 chars of Item Code\r\n    item_prefix = doc.tds_item[:4]\r\n    year = frappe.utils.getdate().strftime(\"%y\")\r\n    plant_code = frappe.db.get_value(\"Production Plant\", doc.plant, \"plant_code\") or \"0\"\r\n    \r\n    # Get last batch for this item/year/plant\r\n    last_batch = frappe.get_all(\"Batch AMB\",\r\n        filters={\r\n            \"tds_item\": doc.tds_item,\r\n            \"creation\": (\">=\", f\"20{year}-01-01\"),\r\n            \"name\": (\"like\", f\"{item_prefix}%{year}{plant_code}\")\r\n        },\r\n        fields=[\"name\"],\r\n        order_by=\"creation DESC\",\r\n        limit=1\r\n    )\r\n    \r\n    # Calculate next consecutive number\r\n    if last_batch:\r\n        last_id = last_batch[0].name\r\n        consecutive = int(last_id[4:7]) + 1  # Positions 5-7\r\n    else:\r\n        consecutive = 1\r\n    \r\n    # Format: ItemPrefix(4) + Consecutive(3) + Year(2) + Plant(1)\r\n    doc.name = f\"{item_prefix}{consecutive:03d}{year}{plant_code}\"\r\n    frappe.msgprint(f\"Generated Batch ID: {doc.name}\")  # Debug\r\n\"\"\"\r\n}).insert()",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.132271",
  "module": "amb_w_tds",
  "name": "Batch PENCA",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "# Batch AMB Server Script - Before Save\r\n#import frappe\r\n#from frappe import _\r\n#from frappe.utils import getdate, add_years\r\n\r\ndef validate(doc, method):\r\n    \"\"\"Validate Batch AMB document before saving\"\"\"\r\n    \r\n    # Ensure lft and rgt are preserved as strings with leading zeros\r\n    if doc.lft and isinstance(doc.lft, int):\r\n        doc.lft = str(doc.lft).zfill(4)  # 4 digits for lft\r\n    if doc.rgt and isinstance(doc.rgt, int):\r\n        doc.rgt = str(doc.rgt).zfill(5)  # 5 digits for rgt (work order format)\r\n    \r\n    # Validate hierarchy\r\n    validate_batch_hierarchy(doc)\r\n    \r\n    # Auto-generate fields\r\n    if not doc.consecutive_number:\r\n        doc.consecutive_number = get_next_consecutive_number(doc)\r\n    \r\n    if doc.consecutive_number and doc.production_plant_name:\r\n        doc.custom_generated_batch_name = generate_batch_code(doc)\r\n        doc.title = doc.custom_generated_batch_name or doc.name\r\n\r\ndef validate_batch_hierarchy(doc):\r\n    \"\"\"Validate batch hierarchy\"\"\"\r\n    if doc.custom_batch_level and int(doc.custom_batch_level) > 1 and not doc.parent_batch_amb:\r\n        frappe.throw(_(\"Parent Batch AMB is required for batch level {0}\").format(doc.custom_batch_level))\r\n\r\ndef get_next_consecutive_number(doc):\r\n    \"\"\"Get next consecutive number\"\"\"\r\n    filters = {\"custom_batch_level\": doc.custom_batch_level}\r\n    if doc.parent_batch_amb:\r\n        filters[\"parent_batch_amb\"] = doc.parent_batch_amb\r\n    \r\n    existing = frappe.get_all(\"Batch AMB\", filters=filters, \r\n                            fields=[\"consecutive_number\"],\r\n                            order_by=\"consecutive_number desc\", limit=1)\r\n    \r\n    return int(existing[0].consecutive_number) + 1 if existing and existing[0].consecutive_number else 1\r\n\r\ndef generate_batch_code(doc):\r\n    \"\"\"Generate batch code preserving string formats\"\"\"\r\n    plant_code = str(doc.production_plant_name)[0].upper() if doc.production_plant_name else \"X\"\r\n    consecutive = str(doc.consecutive_number).zfill(3)\r\n    \r\n    lft_str = str(doc.lft or \"0000\").zfill(4)\r\n    rgt_str = str(doc.rgt or \"00000\").zfill(5)\r\n    \r\n    return f\"{lft_str}{rgt_str}{plant_code}{consecutive}\"",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.222098",
  "module": "amb_w_tds",
  "name": "Fetch TDS Version Validation",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "TDS Product Specification",
  "script": "# Optional validation to ensure sequence numbers stay in sync\r\ndef validate(doc, method):\r\n    if doc.tds_sequence:\r\n        # Get current sequence from TDS Settings\r\n        current_seq = frappe.db.get_value(\"TDS Settings\", {\"item_code\": doc.item_code}, \"last_sequence_used\") or 0\r\n        \r\n        # Ensure our sequence isn't higher than what's recorded\r\n        if doc.tds_sequence > current_seq + 1:\r\n            frappe.throw(f\"Sequence number {doc.tds_sequence} is too high. Current sequence is {current_seq}\")",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Print",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.211489",
  "module": "amb_w_tds",
  "name": "Sales Order PDF Processor",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Order",
  "script": "# Ultra-simplified Sales Order Processor for Frappe Cloud\r\n\r\n# Main processing function\r\ndef process_order(doc):\r\n    try:\r\n        # Create basic response structure\r\n        result = {\r\n            'status': 'success',\r\n            'data': {\r\n                'doctype': 'Sales Order',\r\n                'items': [{\r\n                    'item_code': 'default_item',\r\n                    'qty': 1\r\n                }]\r\n            }\r\n        }\r\n        \r\n        # Directly use doc as dictionary (no JSON parsing needed)\r\n        if 'name' in doc:\r\n            result['data']['name'] = doc['name']\r\n        if 'customer' in doc:\r\n            result['data']['customer'] = doc['customer']\r\n        if 'po_no' in doc:\r\n            result['data']['po_no'] = doc['po_no']\r\n        \r\n        # Simple text extraction from terms\r\n        terms = doc.get('terms', '')\r\n        if 'Codigo a Facturar' in terms:\r\n            result['data']['custom_codigo'] = '0334'  # Hardcoded example\r\n        \r\n        return result\r\n        \r\n    except Exception as e:\r\n        return {\r\n            'status': 'error',\r\n            'message': str(e)\r\n        }\r\n\r\n# Direct execution - doc is already available as a dict in server scripts\r\nresult = process_order(doc)\r\nfrappe.response.update(result)",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Print",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.871761",
  "module": "amb_w_tds",
  "name": "pdf_to_erpnext_processor",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Order",
  "script": "# frappe/server_scripts/sales_order_pdf_processor.py\r\n\r\n#import frappe\r\n#from frappe import _\r\n#from frappe.utils import nowdate, getdate, flt, cstr\r\n#from frappe.model.document import Document\r\n\r\n#@frappe.whitelist()\r\ndef process_sales_order_pdf(pdf_content, sales_order_name=None):\r\n    \"\"\"\r\n    Process PDF content and update Sales Order with extracted data\r\n    Whitelisted for API calls\r\n    \"\"\"\r\n    try:\r\n        # Validate input\r\n        if not pdf_content:\r\n            frappe.throw(_(\"PDF content is required\"))\r\n        \r\n        # Get or create Sales Order\r\n        if sales_order_name and frappe.db.exists(\"Sales Order\", sales_order_name):\r\n            so = frappe.get_doc(\"Sales Order\", sales_order_name)\r\n        else:\r\n            so = frappe.new_doc(\"Sales Order\")\r\n            so.company = frappe.defaults.get_user_default(\"company\")\r\n            so.transaction_date = nowdate()\r\n        \r\n        # Extract data from PDF content\r\n        extracted_data = extract_order_data_from_pdf(pdf_content)\r\n        \r\n        # Update Sales Order with extracted data\r\n        update_sales_order(so, extracted_data)\r\n        \r\n        # Save the document\r\n        so.save()\r\n        \r\n        return {\r\n            \"status\": \"success\",\r\n            \"sales_order\": so.name,\r\n            \"message\": _(\"Sales Order processed successfully\")\r\n        }\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(\r\n            title=_(\"PDF Processing Error\"),\r\n            message=f\"Error processing PDF for Sales Order: {str(e)}\"\r\n        )\r\n        return {\r\n            \"status\": \"error\",\r\n            \"message\": _(\"Error processing PDF: {0}\").format(str(e))\r\n        }\r\n\r\ndef extract_order_data_from_pdf(pdf_content):\r\n    \"\"\"\r\n    Extract structured data from PDF text content using safe methods\r\n    \"\"\"\r\n    data = {\r\n        \"doctype\": \"Sales Order\",\r\n        \"items\": [],\r\n        \"custom_fields\": {}\r\n    }\r\n    \r\n    # Handle JSON input\r\n    text_content = pdf_content\r\n    if pdf_content.strip().startswith('{'):\r\n        try:\r\n            content_data = frappe.parse_json(pdf_content)\r\n            text_content = content_data.get(\"text_in_pdf\", pdf_content)\r\n        except:\r\n            pass\r\n    \r\n    # Extract basic information using string methods\r\n    data.update(extract_basic_info(text_content))\r\n    data.update(extract_customer_info(text_content))\r\n    data.update(extract_product_info(text_content))\r\n    data.update(extract_specifications(text_content))\r\n    \r\n    return data\r\n\r\ndef extract_basic_info(text):\r\n    \"\"\"Extract basic order information using string methods\"\"\"\r\n    info = {}\r\n    \r\n    # Order number\r\n    if \"Numero Pedido\" in text:\r\n        parts = text.split(\"Numero Pedido\")\r\n        if len(parts) > 1:\r\n            order_part = parts[1].split()[0] if parts[1].split() else \"\"\r\n            info[\"name\"] = order_part.strip()\r\n    \r\n    # Purchase order\r\n    if \"Orde de Compra\" in text:\r\n        parts = text.split(\"Orde de Compra\")\r\n        if len(parts) > 1:\r\n            po_part = parts[1].split()[0] if parts[1].split() else \"\"\r\n            info[\"po_no\"] = po_part.strip()\r\n    \r\n    # Dates - simplified date extraction\r\n    date_patterns = [\r\n        (\"Fecha de Registro\", \"registration_date\"),\r\n        (\"Fecha de Orden\", \"po_date\"),\r\n        (\"Fecha de Entrega\", \"delivery_date\")\r\n    ]\r\n    \r\n    for pattern, field in date_patterns:\r\n        if pattern in text:\r\n            parts = text.split(pattern)\r\n            if len(parts) > 1:\r\n                date_part = parts[1].split()[0] if parts[1].split() else \"\"\r\n                if \"/\" in date_part:\r\n                    info[field] = parse_date_string(date_part)\r\n    \r\n    return info\r\n\r\ndef extract_customer_info(text):\r\n    \"\"\"Extract customer information\"\"\"\r\n    info = {}\r\n    \r\n    # Customer name\r\n    if \"Cliente\\\\Distribuidor\" in text:\r\n        parts = text.split(\"Cliente\\\\Distribuidor\")\r\n        if len(parts) > 1:\r\n            customer_part = parts[1].split(\"\\n\")[0] if \"\\n\" in parts[1] else parts[1]\r\n            customer_name = customer_part.strip()\r\n            info[\"customer\"] = customer_name\r\n            info[\"customer_name\"] = customer_name\r\n    \r\n    # Subcliente\r\n    if \"Subcliente\" in text:\r\n        parts = text.split(\"Subcliente\")\r\n        if len(parts) > 1:\r\n            subclient_part = parts[1].split(\"Codigo\")[0] if \"Codigo\" in parts[1] else parts[1]\r\n            info[\"custom_subcliente\"] = subclient_part.strip()\r\n    \r\n    return info\r\n\r\ndef extract_product_info(text):\r\n    \"\"\"Extract product information\"\"\"\r\n    info = {\"items\": []}\r\n    \r\n    # Look for product patterns\r\n    lines = text.split(\"\\n\")\r\n    for i, line in enumerate(lines):\r\n        line = line.strip()\r\n        \r\n        # Simple pattern matching for product lines\r\n        if len(line.split()) >= 3 and any(char.isdigit() for char in line.split()[0]):\r\n            parts = line.split()\r\n            try:\r\n                # Try to parse as item code, quantity, unit\r\n                item_code = parts[0]\r\n                qty = flt(parts[1])\r\n                uom = parts[2].replace('.', '')\r\n                \r\n                # Description is the rest of the line\r\n                description = \" \".join(parts[3:]) if len(parts) > 3 else item_code\r\n                \r\n                item = {\r\n                    \"item_code\": find_matching_item(item_code, description),\r\n                    \"qty\": qty,\r\n                    \"uom\": uom,\r\n                    \"item_name\": description,\r\n                    \"description\": description\r\n                }\r\n                info[\"items\"].append(item)\r\n                \r\n            except (ValueError, IndexError):\r\n                continue\r\n    \r\n    return info\r\n\r\ndef extract_specifications(text):\r\n    \"\"\"Extract specifications and custom fields\"\"\"\r\n    info = {\"custom_fields\": {}}\r\n    \r\n    # Observations\r\n    if \"Observaciones\" in text:\r\n        parts = text.split(\"Observaciones\")\r\n        if len(parts) > 1:\r\n            obs_part = parts[1].split(\"TDS\")[0] if \"TDS\" in parts[1] else parts[1]\r\n            info[\"custom_fields\"][\"custom_observaciones\"] = obs_part.strip()[:140]  # Limit length\r\n    \r\n    # Shipping methods\r\n    shipping_methods = {\r\n        \"Terrestre\": \"custom_embarque_terrestre\",\r\n        \"Maritimo\": \"custom_embarque_maritimo\", \r\n        \"Aereo\": \"custom_embarque_aereo\"\r\n    }\r\n    \r\n    for method, field in shipping_methods.items():\r\n        if method.lower() in text.lower():\r\n            info[\"custom_fields\"][field] = f\"✓ {method}\"\r\n    \r\n    return info\r\n\r\ndef find_matching_item(item_code, description):\r\n    \"\"\"\r\n    Find matching item in ERPNext system\r\n    \"\"\"\r\n    # First try exact item code match\r\n    if frappe.db.exists(\"Item\", item_code):\r\n        return item_code\r\n    \r\n    # Try partial match in item code\r\n    items = frappe.get_all(\"Item\", \r\n        filters={\"item_code\": [\"like\", f\"%{item_code}%\"]},\r\n        fields=[\"item_code\", \"item_name\"]\r\n    )\r\n    \r\n    if items:\r\n        return items[0].item_code\r\n    \r\n    # Try description match\r\n    items = frappe.get_all(\"Item\",\r\n        filters={\"item_name\": [\"like\", f\"%{description[:20]}%\"]},\r\n        fields=[\"item_code\", \"item_name\"]\r\n    )\r\n    \r\n    if items:\r\n        return items[0].item_code\r\n    \r\n    # Return original code if no match found\r\n    return item_code\r\n\r\ndef parse_date_string(date_str):\r\n    \"\"\"\r\n    Parse date string safely\r\n    \"\"\"\r\n    try:\r\n        # Handle DD/MM/YY format\r\n        if \"/\" in date_str:\r\n            parts = date_str.split(\"/\")\r\n            if len(parts) == 3:\r\n                day, month, year = parts\r\n                year = f\"20{year}\" if len(year) == 2 else year\r\n                return f\"{year}-{month.zfill(2)}-{day.zfill(2)}\"\r\n    except:\r\n        pass\r\n    \r\n    return nowdate()\r\n\r\ndef update_sales_order(sales_order, extracted_data):\r\n    \"\"\"\r\n    Update Sales Order with extracted data\r\n    \"\"\"\r\n    # Update basic fields\r\n    for field in [\"name\", \"po_no\", \"delivery_date\"]:\r\n        if field in extracted_data and extracted_data[field]:\r\n            sales_order.set(field, extracted_data[field])\r\n    \r\n    # Update customer if not already set\r\n    if \"customer\" in extracted_data and extracted_data[\"customer\"] and not sales_order.customer:\r\n        sales_order.customer = extracted_data[\"customer\"]\r\n        sales_order.customer_name = extracted_data.get(\"customer_name\", extracted_data[\"customer\"])\r\n    \r\n    # Add items if not already present\r\n    if extracted_data.get(\"items\") and not sales_order.items:\r\n        for item_data in extracted_data[\"items\"]:\r\n            sales_order.append(\"items\", {\r\n                \"item_code\": item_data.get(\"item_code\"),\r\n                \"qty\": item_data.get(\"qty\", 1),\r\n                \"uom\": item_data.get(\"uom\", \"Nos\"),\r\n                \"item_name\": item_data.get(\"item_name\"),\r\n                \"description\": item_data.get(\"description\")\r\n            })\r\n    \r\n    # Update custom fields\r\n    custom_fields = extracted_data.get(\"custom_fields\", {})\r\n    for field, value in custom_fields.items():\r\n        if hasattr(sales_order, field):\r\n            sales_order.set(field, value)\r\n\r\n#@frappe.whitelist()\r\ndef get_pdf_processing_settings():\r\n    \"\"\"\r\n    Get settings for PDF processing\r\n    \"\"\"\r\n    return {\r\n        \"supported_fields\": [\r\n            \"customer\", \"po_no\", \"delivery_date\", \"items\",\r\n            \"custom_subcliente\", \"custom_observaciones\",\r\n            \"custom_embarque_terrestre\", \"custom_embarque_maritimo\", \"custom_embarque_aereo\"\r\n        ],\r\n        \"required_fields\": [\"customer\", \"items\"]\r\n    }\r\n\r\n# Client-side JavaScript integration\r\n\"\"\"\r\n// Example client-side usage:\r\nfrappe.call({\r\n    method: 'your_app.sales_order_pdf_processor.process_sales_order_pdf',\r\n    args: {\r\n        pdf_content: pdfTextContent,\r\n        sales_order_name: 'SO-01825-Barentz Italia Specchiasol' // optional\r\n    },\r\n    callback: function(response) {\r\n        if (response.message.status === 'success') {\r\n            frappe.show_alert('PDF processed successfully');\r\n            frappe.set_route('Form', 'Sales Order', response.message.sales_order);\r\n        } else {\r\n            frappe.msgprint('Error: ' + response.message.message);\r\n        }\r\n    }\r\n});\r\n\"\"\"",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": "/api/method/raven_webhook_handler.handle",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.177821",
  "module": "amb_w_tds",
  "name": "Raven Webhook Handler Script",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Raven Webhook Handler",
  "script": "@frappe.whitelist(allow_guest=True)\r\ndef handle():\r\n    # Verify secret if needed\r\n    secret = frappe.get_request_header(\"X-Raven-Secret\")\r\n    if secret != frappe.conf.raven_webhook_secret:\r\n        frappe.throw(\"Invalid secret\", frappe.AuthenticationError)\r\n    \r\n    data = frappe.request.get_json()\r\n    # Process your webhook data here\r\n    \r\n    return {\"status\": \"success\"}\r\ndef validate(doc, method):\r\n    # Auto-set the webhook handler link in child table\r\n    for row in doc.get(\"trigger_events\", []):\r\n        if not row.webhook_handler:\r\n            row.webhook_handler = doc.name\r\n    \r\n    # Validate at least one trigger is enabled\r\n    if not any(row.enabled for row in doc.get(\"trigger_events\", [])):\r\n        frappe.throw(\"Please enable at least one trigger event\", title=\"Configuration Error\")\r\n        # In your hooks.py or custom app\r\nfrom frappe import whitelist\r\n\r\n@whitelist(allow_guest=True)\r\ndef handle_sales_order_webhook():\r\n    # 1. Verify request\r\n    verify_webhook()\r\n    \r\n    # 2. Get payload\r\n    payload = frappe.request.get_json()\r\n    so_name = payload.get('name')\r\n    \r\n    # 3. Process based on workflow state\r\n    if payload.get('workflow_state') == 'Submitted':\r\n        create_installation_project(payload)\r\n        reserve_inventory(so_name)\r\n        notify_team(payload)\r\n    \r\n    return {\"success\": True}\r\n\r\n@whitelist(allow_guest=True)\r\ndef create_installation_project(payload):\r\n    \"\"\"Create project in Project Management tool\"\"\"\r\n    project = frappe.get_doc({\r\n        'doctype': 'Project',\r\n        'project_name': f\"Installation - {payload['customer']}\",\r\n        'expected_start_date': payload['delivery_date'],\r\n        'sales_order': payload['name']\r\n    }).insert()\r\n    \r\n# In hooks.py\r\ndef handle_sales_order(doc, method):\r\n    if doc.doctype == 'Sales Order' and doc.workflow_state == 'Submitted':\r\n        frappe.enqueue(\r\n            'your_app.webhooks.process_sales_order',\r\n            sales_order=doc.name\r\n        )\r\n\r\ndef process_sales_order(sales_order):\r\n    doc = frappe.get_doc('Sales Order', sales_order)\r\n    \r\n    payload = {\r\n        'event': 'order_submitted',\r\n        'order_id': doc.name,\r\n        'customer': doc.customer_name,\r\n        'amount': doc.grand_total\r\n    }\r\n    \r\n    # Send to Raven or external system\r\n    frappe.make_post_request(\r\n        url='https://your-endpoint.com/webhook',\r\n        data=payload,\r\n        headers={'Authorization': 'Bearer your-token'}\r\n    )\r\n",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "/api/method/sales_order_staus.handle",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.201201",
  "module": "amb_w_tds",
  "name": "/api/method/raven_webhook_handler.handle",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Raven Webhook Handler",
  "script": "from frappe import whitelist\r\nimport frappe\r\n\r\n@frappe.whitelist(allow_guest=True)\r\ndef handle_webhook(**kwargs):\r\n    try:\r\n        data = frappe.request.get_json()\r\n        \r\n        # Validate the request if needed\r\n        # Process the webhook data\r\n        \r\n        return {\"success\": True, \"message\": \"Webhook processed\"}\r\n    except Exception as e:\r\n        frappe.log_error(title=\"Raven Webhook Error\")\r\n        return {\"success\": False, \"error\": str(e)}",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.190088",
  "module": "amb_w_tds",
  "name": "Triggers Script",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Sales Order",
  "script": "def handle_doctype_event(doc, method):\r\n    \"\"\"Called from document hooks\"\"\"\r\n    webhooks = frappe.get_all(\"Raven Webhook Handler\",\r\n        filters={\r\n            \"enabled\": 1,\r\n            \"doc_type\": doc.doctype\r\n        },\r\n        pluck=\"name\"\r\n    )\r\n    \r\n    for webhook_name in webhooks:\r\n        webhook = frappe.get_doc(\"Raven Webhook Handler\", webhook_name)\r\n        \r\n        # Get enabled events for this webhook\r\n        enabled_events = [\r\n            row.event for row in webhook.trigger_events \r\n            if row.enabled and row.webhook_handler == webhook.name\r\n        ]\r\n        \r\n        if method.replace(\"on_\", \"\").replace(\"_\", \" \") in enabled_events:\r\n            process_webhook(webhook, doc)",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 1,
  "api_method": "/api/method/sales_order_webhook.handler",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.166863",
  "module": "amb_w_tds",
  "name": "Sales Order Webhook Handler",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Raven Webhook Handler",
  "script": "import frappe\r\nimport hmac\r\nimport hashlib\r\n\r\n@frappe.whitelist(allow_guest=True)\r\ndef handler():\r\n    # 1. Verify signature\r\n    secret = frappe.get_site_config().so_webhook_secret\r\n    signature = frappe.get_request_header(\"X-Signature\")\r\n    payload = frappe.request.get_data(as_text=True)\r\n    \r\n    if not secret:\r\n        frappe.throw(\"Webhook secret not configured\")\r\n    \r\n    computed_sig = hmac.new(\r\n        secret.encode('utf-8'),\r\n        payload.encode('utf-8'),\r\n        hashlib.sha256\r\n    ).hexdigest()\r\n    \r\n    if not hmac.compare_digest(signature, computed_sig):\r\n        frappe.throw(\"Invalid signature\", frappe.AuthenticationError)\r\n\r\n    # 2. Process payload\r\n    data = frappe.parse_json(payload)\r\n    \r\n    if data.get('event') == 'sales_order_submit':\r\n        so_name = data.get('name')\r\n        \r\n        # Create project\r\n        frappe.get_doc({\r\n            'doctype': 'Project',\r\n            'project_name': f\"SO Installation - {so_name}\",\r\n            'sales_order': so_name,\r\n            'expected_start_date': frappe.utils.today()\r\n        }).insert(ignore_permissions=True)\r\n        \r\n        frappe.db.commit()\r\n        \r\n    return {'status': 'processed'}",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.957814",
  "module": "amb_w_tds",
  "name": "Work Order Zone Assignment",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Work Order",
  "script": "# Auto-assign zone based on warehouse - Safe version\r\ntry:\r\n    if doc.source_warehouse:\r\n        warehouse_name = doc.source_warehouse.upper()\r\n        \r\n        frappe.msgprint(f\"Checking warehouse: {warehouse_name}\")\r\n        \r\n        # Check for Red Zone keywords (manual checks)\r\n        is_red_zone = False\r\n        if \"QC\" in warehouse_name:\r\n            is_red_zone = True\r\n        elif \"HOLD\" in warehouse_name:\r\n            is_red_zone = True\r\n        elif \"QUARANTINE\" in warehouse_name:\r\n            is_red_zone = True\r\n        elif \"INSPECTION\" in warehouse_name:\r\n            is_red_zone = True\r\n        elif \"SCRAP\" in warehouse_name:\r\n            is_red_zone = True\r\n        \r\n        # Check for Green Zone keywords (manual checks)\r\n        is_green_zone = False\r\n        if \"FG\" in warehouse_name:\r\n            is_green_zone = True\r\n        elif \"FINISHED\" in warehouse_name:\r\n            is_green_zone = True\r\n        elif \"STAGING\" in warehouse_name:\r\n            is_green_zone = True\r\n        elif \"KIT\" in warehouse_name:\r\n            is_green_zone = True\r\n        elif \"GREEN\" in warehouse_name:\r\n            is_green_zone = True\r\n        \r\n        # Zone assignment\r\n        if is_red_zone:\r\n            doc.custom_zone_assignment = \"Red Zone\"\r\n            doc.custom_scanning_required = 1\r\n            frappe.msgprint(\"✅ Assigned to Red Zone\")\r\n            \r\n        elif is_green_zone:\r\n            doc.custom_zone_assignment = \"Green Zone\"\r\n            doc.custom_scanning_required = 0\r\n            frappe.msgprint(\"✅ Assigned to Green Zone\")\r\n            \r\n        else:\r\n            doc.custom_zone_assignment = \"Transfer Zone\"\r\n            doc.custom_scanning_required = 1\r\n            frappe.msgprint(\"⚠️ Assigned to Transfer Zone\")\r\n            \r\nexcept Exception as e:\r\n    frappe.msgprint(f\"❌ Error: {str(e)}\")\r\n    frappe.log_error(f\"Work Order Zone Error: {str(e)}\")",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.143992",
  "module": "amb_w_tds",
  "name": "Stock Entry Zone Validation",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Stock Entry",
  "script": "# Stock Entry Zone Validation\r\n# This script validates Stock Entry based on custom zone type\r\n\r\n# Check if custom_zone_type field exists and has value\r\nif hasattr(doc, 'custom_zone_type') and doc.custom_zone_type:\r\n    # Strip any whitespace from zone type\r\n    zone_type = doc.custom_zone_type.strip()\r\n    \r\n    # Red Zone validation\r\n    if zone_type == \"Red Zone\":\r\n        # Check if both signatures exist\r\n        if not getattr(doc, 'custom_supervisor_signature', None) or not getattr(doc, 'custom_operator_signature', None):\r\n            frappe.throw(\"Red Zone operations require both supervisor and operator signatures\")\r\n        \r\n        # Set workflow for manual approval\r\n        if hasattr(doc, 'workflow_state'):\r\n            doc.workflow_state = \"Pending Approval\"\r\n    \r\n    # Green Zone processing\r\n    elif zone_type == \"Green Zone\":\r\n        # Set auto-approval\r\n        if hasattr(doc, 'custom_automatic_posting'):\r\n            doc.custom_automatic_posting = 1\r\n        \r\n        if hasattr(doc, 'workflow_state'):\r\n            doc.workflow_state = \"Auto Approved\"\r\n\r\n# Movement type validation (warning only)\r\nif hasattr(doc, 'custom_movement_type') and doc.custom_movement_type:\r\n    movement_type = str(doc.custom_movement_type).strip()\r\n    if movement_type in [\"261\", \"311\"] and not getattr(doc, 'custom_supervisor_signature', None):\r\n        frappe.msgprint(\r\n            \"Supervisor signature recommended for movement type {}\".format(movement_type),\r\n            indicator=\"orange\",\r\n            alert=True\r\n        )",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.014494",
  "module": "amb_w_tds",
  "name": "Batch AMB Penca",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "# Batch AMB Server Script\r\n# Place this code in Server Script doctype with Event: Before Save\r\n\r\n#import frappe\r\n#from frappe import _\r\n#from frappe.utils import now_datetime, getdate, add_years\r\n\r\ndef validate(doc, method):\r\n    \"\"\"Validate Batch AMB document before saving\"\"\"\r\n    \r\n    # Validate batch level hierarchy\r\n    validate_batch_hierarchy(doc)\r\n    \r\n    # Validate consecutive number uniqueness\r\n    validate_consecutive_number(doc)\r\n    \r\n    # Auto-generate fields if not set\r\n    auto_generate_fields(doc)\r\n    \r\n    # Validate batch code format\r\n    validate_batch_code(doc)\r\n    \r\n    # Set tree structure fields\r\n    set_tree_fields(doc)\r\n\r\ndef validate_batch_hierarchy(doc):\r\n    \"\"\"Validate that batch hierarchy is correct\"\"\"\r\n    \r\n    if doc.custom_batch_level and int(doc.custom_batch_level) > 1:\r\n        if not doc.parent_batch_amb:\r\n            frappe.throw(_(\"Parent Batch AMB is required for batch level {0}\").format(doc.custom_batch_level))\r\n        \r\n        # Validate that parent exists and has correct level\r\n        parent_batch = frappe.get_doc(\"Batch AMB\", doc.parent_batch_amb)\r\n        parent_level = int(parent_batch.custom_batch_level or 1)\r\n        current_level = int(doc.custom_batch_level)\r\n        \r\n        if current_level != parent_level + 1:\r\n            frappe.throw(_(\"Batch level must be one level below parent. Parent level: {0}, Current level: {1}\").format(parent_level, current_level))\r\n\r\ndef validate_consecutive_number(doc):\r\n    \"\"\"Validate that consecutive number is unique within the same level and parent\"\"\"\r\n    \r\n    if not doc.consecutive_number:\r\n        return\r\n    \r\n    filters = {\r\n        \"consecutive_number\": doc.consecutive_number,\r\n        \"custom_batch_level\": doc.custom_batch_level,\r\n        \"lft\": doc.lft\r\n    }\r\n    \r\n    if doc.parent_batch_amb:\r\n        filters[\"parent_batch_amb\"] = doc.parent_batch_amb\r\n    \r\n    if not doc.is_new():\r\n        filters[\"name\"] = [\"!=\", doc.name]\r\n    \r\n    existing = frappe.get_list(\"Batch AMB\", filters=filters, limit=1)\r\n    \r\n    if existing:\r\n        frappe.throw(_(\"Consecutive number {0} already exists for this batch level and parent\").format(doc.consecutive_number))\r\n\r\ndef auto_generate_fields(doc):\r\n    \"\"\"Auto-generate required fields if not set\"\"\"\r\n    \r\n    # Auto-generate consecutive number if not set\r\n    if not doc.consecutive_number:\r\n        doc.consecutive_number = get_next_consecutive_number(doc)\r\n    \r\n    # Auto-generate batch code\r\n    if doc.lft and doc.rgt and doc.consecutive_number and doc.production_plant_name:\r\n        doc.custom_generated_batch_name = generate_batch_code(doc)\r\n        doc.title = doc.custom_generated_batch_name\r\n    \r\n    # Set expiry date if not set (default to 2 years from today)\r\n    if not doc.expiry_date:\r\n        doc.expiry_date = add_years(getdate(), 2)\r\n    \r\n    # Set is_group flag\r\n    doc.is_group = 1 if has_child_batches(doc) else 0\r\n\r\ndef get_next_consecutive_number(doc):\r\n    \"\"\"Get next consecutive number for the batch\"\"\"\r\n    \r\n    filters = {\r\n        \"custom_batch_level\": doc.custom_batch_level,\r\n        \"lft\": doc.lft\r\n    }\r\n    \r\n    if doc.parent_batch_amb:\r\n        filters[\"parent_batch_amb\"] = doc.parent_batch_amb\r\n    \r\n    existing_batches = frappe.get_list(\r\n        \"Batch AMB\",\r\n        filters=filters,\r\n        fields=[\"consecutive_number\"],\r\n        order_by=\"consecutive_number desc\",\r\n        limit=1\r\n    )\r\n    \r\n    if existing_batches:\r\n        return int(existing_batches[0].consecutive_number or 0) + 1\r\n    else:\r\n        return 1\r\n\r\ndef generate_batch_code(doc):\r\n    \"\"\"Generate batch code based on AMB requirements\"\"\"\r\n    \r\n    try:\r\n        # Get plant code (first character of production plant name)\r\n        plant_code = str(doc.production_plant_name)[0] if doc.production_plant_name else \"0\"\r\n        \r\n        # Format consecutive number as 3 digits\r\n        consecutive_formatted = str(doc.consecutive_number).zfill(3)\r\n        \r\n        # Base batch code: lft(4) + rgt(5) + plant(1) + consecutive(3)\r\n        batch_code = f\"{doc.lft}{doc.rgt}{plant_code}{consecutive_formatted}\"\r\n        \r\n        # Add level-specific suffixes\r\n        level_suffix = get_batch_level_suffix(doc)\r\n        \r\n        return batch_code + level_suffix\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error generating batch code: {str(e)}\", \"Batch AMB Code Generation\")\r\n        return None\r\n\r\ndef get_batch_level_suffix(doc):\r\n    \"\"\"Get suffix based on batch level\"\"\"\r\n    \r\n    level = doc.custom_batch_level\r\n    \r\n    if level == \"1\":\r\n        # Level 1: No suffix (parent batch)\r\n        return \"\"\r\n    elif level == \"2\":\r\n        # Level 2: Sub-lots with -1, -2, etc.\r\n        return f\"-{doc.consecutive_number}\"\r\n    elif level == \"3\":\r\n        # Level 3: Containers with -001, -002, etc.\r\n        container_num = str(doc.consecutive_number).zfill(3)\r\n        return f\"-{container_num}\"\r\n    elif level == \"4\":\r\n        # Level 4: Pallets with -P1, -P2, etc.\r\n        return f\"-P{doc.consecutive_number}\"\r\n    else:\r\n        return \"\"\r\n\r\ndef validate_batch_code(doc):\r\n    \"\"\"Validate that batch code follows AMB format\"\"\"\r\n    \r\n    if not doc.custom_generated_batch_name:\r\n        return\r\n    \r\n    # Check for duplicate batch codes\r\n    filters = {\"custom_generated_batch_name\": doc.custom_generated_batch_name}\r\n    if not doc.is_new():\r\n        filters[\"name\"] = [\"!=\", doc.name]\r\n    \r\n    existing = frappe.get_list(\"Batch AMB\", filters=filters, limit=1)\r\n    \r\n    if existing:\r\n        frappe.throw(_(\"Batch code {0} already exists\").format(doc.custom_generated_batch_name))\r\n\r\ndef set_tree_fields(doc):\r\n    \"\"\"Set tree structure fields for hierarchical display\"\"\"\r\n    \r\n    # Set is_group based on whether batch has children\r\n    doc.is_group = 1 if has_child_batches(doc) else 0\r\n    \r\n    # Update parent batches to set is_group flag\r\n    if doc.parent_batch_amb:\r\n        parent_batch = frappe.get_doc(\"Batch AMB\", doc.parent_batch_amb)\r\n        parent_batch.is_group = 1\r\n        parent_batch.save(ignore_permissions=True)\r\n\r\ndef has_child_batches(doc):\r\n    \"\"\"Check if batch has child batches\"\"\"\r\n    \r\n    if doc.is_new():\r\n        return False\r\n    \r\n    child_batches = frappe.get_list(\r\n        \"Batch AMB\",\r\n        filters={\"parent_batch_amb\": doc.name},\r\n        limit=1\r\n    )\r\n    \r\n    return len(child_batches) > 0\r\n\r\n# Hook functions for document events\r\ndef on_update(doc, method):\r\n    \"\"\"Update tree structure after document update\"\"\"\r\n    frappe.clear_cache(doctype=\"Batch AMB\")\r\n\r\ndef on_trash(doc, method):\r\n    \"\"\"Validate before deleting batch\"\"\"\r\n    \r\n    # Check if batch has children\r\n    if has_child_batches(doc):\r\n        frappe.throw(_(\"Cannot delete batch {0} because it has child batches\").format(doc.name))\r\n    \r\n    # Update parent batch is_group flag if this was the last child\r\n    if doc.parent_batch_amb:\r\n        remaining_children = frappe.get_list(\r\n            \"Batch AMB\",\r\n            filters={\r\n                \"parent_batch_amb\": doc.parent_batch_amb,\r\n                \"name\": [\"!=\", doc.name]\r\n            },\r\n            limit=1\r\n        )\r\n        \r\n        if not remaining_children:\r\n            parent_batch = frappe.get_doc(\"Batch AMB\", doc.parent_batch_amb)\r\n            parent_batch.is_group = 0\r\n            parent_batch.save(ignore_permissions=True)\r\n\r\n# Utility functions for client-side calls\r\n#@frappe.whitelist()\r\ndef get_work_order_details(work_order_name):\r\n    \"\"\"Get Work Order details for client script\"\"\"\r\n    \r\n    try:\r\n        work_order = frappe.get_doc(\"Work Order\", work_order_name)\r\n        \r\n        return {\r\n            \"production_item\": work_order.production_item,\r\n            \"item_name\": work_order.item_name,\r\n            \"production_plant_name\": getattr(work_order, \"production_plant_name\", \"\"),\r\n            \"sales_order\": getattr(work_order, \"sales_order\", \"\"),\r\n            \"planned_end_date\": work_order.planned_end_date\r\n        }\r\n    except Exception as e:\r\n        frappe.log_error(f\"Error fetching Work Order details: {str(e)}\", \"Batch AMB Work Order Fetch\")\r\n        return None\r\n\r\n#@frappe.whitelist()\r\ndef get_batch_tree(batch_name):\r\n    \"\"\"Get complete batch hierarchy tree\"\"\"\r\n    \r\n    def get_children(parent_name):\r\n        children = frappe.get_list(\r\n            \"Batch AMB\",\r\n            filters={\"parent_batch_amb\": parent_name},\r\n            fields=[\"name\", \"title\", \"custom_batch_level\", \"custom_generated_batch_name\"],\r\n            order_by=\"custom_batch_level, consecutive_number\"\r\n        )\r\n        \r\n        for child in children:\r\n            child[\"children\"] = get_children(child[\"name\"])\r\n        \r\n        return children\r\n    \r\n    # Get root batch\r\n    root_batch = frappe.get_doc(\"Batch AMB\", batch_name)\r\n    \r\n    # If this is not a root batch, find the root\r\n    while root_batch.parent_batch_amb:\r\n        root_batch = frappe.get_doc(\"Batch AMB\", root_batch.parent_batch_amb)\r\n    \r\n    # Build tree structure\r\n    tree = {\r\n        \"name\": root_batch.name,\r\n        \"title\": root_batch.title,\r\n        \"custom_batch_level\": root_batch.custom_batch_level,\r\n        \"custom_generated_batch_name\": root_batch.custom_generated_batch_name,\r\n        \"children\": get_children(root_batch.name)\r\n    }\r\n    \r\n    return tree\r\n\r\n#@frappe.whitelist()\r\ndef create_child_batch(parent_batch_name, batch_level):\r\n    \"\"\"Create a new child batch\"\"\"\r\n    \r\n    try:\r\n        parent_batch = frappe.get_doc(\"Batch AMB\", parent_batch_name)\r\n        \r\n        # Create new batch document\r\n        new_batch = frappe.new_doc(\"Batch AMB\")\r\n        new_batch.parent_batch_amb = parent_batch_name\r\n        new_batch.custom_batch_level = str(int(parent_batch.custom_batch_level) + 1)\r\n        new_batch.work_order_ref = parent_batch.work_order_ref\r\n        new_batch.production_plant_name = parent_batch.production_plant_name\r\n        new_batch.lft = parent_batch.lft\r\n        new_batch.rgt = parent_batch.rgt\r\n        new_batch.wo_item_name = parent_batch.wo_item_name\r\n        new_batch.item_to_manufacture = parent_batch.item_to_manufacture\r\n        \r\n        return new_batch.as_dict()\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error creating child batch: {str(e)}\", \"Batch AMB Child Creation\")\r\n        frappe.throw(_(\"Error creating child batch: {0}\").format(str(e)))",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.032286",
  "module": "amb_w_tds",
  "name": "Batch AMB Validations",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "#import frappe\r\n#from frappe import _\r\n#from frappe.utils import getdate, add_years\r\n#from frappe.utils.nestedset import rebuild_tree\r\n\r\n# Global flag to prevent recursion\r\namb_updating_nsm = False\r\n\r\ndef validate(doc, method):\r\n    \"\"\"Main validation function for Batch AMB\"\"\"\r\n    if frappe.flags.in_install or frappe.flags.in_migrate:\r\n        return\r\n        \r\n    # Ensure lft and rgt are preserved as strings with leading zeros\r\n    ensure_string_formats(doc)\r\n    \r\n    # Validate batch hierarchy\r\n    validate_batch_hierarchy(doc)\r\n    \r\n    # Validate consecutive number uniqueness\r\n    validate_consecutive_number(doc)\r\n    \r\n    # Auto-generate required fields\r\n    auto_generate_fields(doc)\r\n    \r\n    # Validate batch code format\r\n    validate_batch_code(doc)\r\n    \r\n    # Handle tree structure updates\r\n    update_tree_structure(doc)\r\n\r\ndef ensure_string_formats(doc):\r\n    \"\"\"Ensure lft and rgt maintain string format with leading zeros\"\"\"\r\n    if doc.lft is None or doc.lft == \"\":\r\n        # Set initial values for new documents\r\n        doc.lft = \"0001\"\r\n        doc.rgt = \"0002\"\r\n    else:\r\n        # Convert integers to properly formatted strings\r\n        if isinstance(doc.lft, int):\r\n            doc.lft = str(doc.lft).zfill(4)\r\n        if isinstance(doc.rgt, int):\r\n            doc.rgt = str(doc.rgt).zfill(5)\r\n        \r\n        # Ensure existing strings have proper padding\r\n        if isinstance(doc.lft, str) and doc.lft.isdigit():\r\n            doc.lft = doc.lft.zfill(4)\r\n        if isinstance(doc.rgt, str) and doc.rgt.isdigit():\r\n            doc.rgt = doc.rgt.zfill(5)\r\n\r\ndef validate_batch_hierarchy(doc):\r\n    \"\"\"Validate that batch hierarchy is correct\"\"\"\r\n    if not doc.custom_batch_level:\r\n        doc.custom_batch_level = \"1\"\r\n    \r\n    level = int(doc.custom_batch_level)\r\n    \r\n    if level > 1 and not doc.parent_batch_amb:\r\n        frappe.throw(_(\"Parent Batch AMB is required for batch level {0}\").format(level))\r\n    \r\n    if doc.parent_batch_amb:\r\n        try:\r\n            parent_batch = frappe.get_doc(\"Batch AMB\", doc.parent_batch_amb)\r\n            parent_level = int(parent_batch.custom_batch_level or \"1\")\r\n            \r\n            if level != parent_level + 1:\r\n                frappe.throw(_(\"Batch level must be one level below parent. Parent level: {0}, Current level: {1}\").format(parent_level, level))\r\n                \r\n        except frappe.DoesNotExistError:\r\n            frappe.throw(_(\"Parent batch {0} does not exist\").format(doc.parent_batch_amb))\r\n\r\ndef validate_consecutive_number(doc):\r\n    \"\"\"Validate that consecutive number is unique within the same level and parent\"\"\"\r\n    if not doc.consecutive_number:\r\n        return\r\n    \r\n    filters = {\r\n        \"consecutive_number\": doc.consecutive_number,\r\n        \"custom_batch_level\": doc.custom_batch_level\r\n    }\r\n    \r\n    if doc.parent_batch_amb:\r\n        filters[\"parent_batch_amb\"] = doc.parent_batch_amb\r\n    else:\r\n        filters[\"parent_batch_amb\"] = [\"is\", \"not set\"]\r\n    \r\n    if not doc.is_new():\r\n        filters[\"name\"] = [\"!=\", doc.name]\r\n    \r\n    existing = frappe.get_all(\"Batch AMB\", filters=filters, limit=1)\r\n    \r\n    if existing:\r\n        frappe.throw(_(\"Consecutive number {0} already exists for this batch level and parent\").format(doc.consecutive_number))\r\n\r\ndef auto_generate_fields(doc):\r\n    \"\"\"Auto-generate required fields if not set\"\"\"\r\n    # Auto-generate consecutive number if not set\r\n    if not doc.consecutive_number:\r\n        doc.consecutive_number = get_next_consecutive_number(doc)\r\n    \r\n    # Auto-generate batch code\r\n    if not doc.custom_generated_batch_name:\r\n        doc.custom_generated_batch_name = generate_batch_code(doc)\r\n    \r\n    # Set title to batch code\r\n    if doc.custom_generated_batch_name:\r\n        doc.title = doc.custom_generated_batch_name\r\n    \r\n    # Set expiry date if not set (default to 2 years from today)\r\n    if not doc.expiry_date:\r\n        doc.expiry_date = add_years(getdate(), 2)\r\n    \r\n    # Set is_group based on batch level\r\n    doc.is_group = 1 if int(doc.custom_batch_level or \"1\") < 4 else 0\r\n\r\ndef get_next_consecutive_number(doc):\r\n    \"\"\"Get next consecutive number for the batch\"\"\"\r\n    filters = {\"custom_batch_level\": doc.custom_batch_level}\r\n    \r\n    if doc.parent_batch_amb:\r\n        filters[\"parent_batch_amb\"] = doc.parent_batch_amb\r\n    else:\r\n        filters[\"parent_batch_amb\"] = [\"is\", \"not set\"]\r\n    \r\n    existing_batches = frappe.get_all(\r\n        \"Batch AMB\",\r\n        filters=filters,\r\n        fields=[\"consecutive_number\"],\r\n        order_by=\"consecutive_number desc\",\r\n        limit=1\r\n    )\r\n    \r\n    if existing_batches and existing_batches[0].consecutive_number:\r\n        return int(existing_batches[0].consecutive_number) + 1\r\n    else:\r\n        return 1\r\n\r\ndef generate_batch_code(doc):\r\n    \"\"\"Generate batch code based on AMB requirements\"\"\"\r\n    try:\r\n        # Get plant code (first character of production plant name)\r\n        plant_code = str(doc.production_plant_name)[0].upper() if doc.production_plant_name else \"X\"\r\n        \r\n        # Format consecutive number as 3 digits\r\n        consecutive_formatted = str(doc.consecutive_number).zfill(3)\r\n        \r\n        # Use formatted lft and rgt values\r\n        lft_str = str(doc.lft or \"0000\").zfill(4)\r\n        rgt_str = str(doc.rgt or \"00000\").zfill(5)\r\n        \r\n        # Base batch code\r\n        batch_code = f\"{lft_str}{rgt_str}{plant_code}{consecutive_formatted}\"\r\n        \r\n        # Add level-specific suffixes\r\n        level = doc.custom_batch_level or \"1\"\r\n        if level == \"2\":\r\n            return f\"{batch_code}-S{doc.consecutive_number}\"\r\n        elif level == \"3\":\r\n            return f\"{batch_code}-C{str(doc.consecutive_number).zfill(3)}\"\r\n        elif level == \"4\":\r\n            return f\"{batch_code}-P{doc.consecutive_number}\"\r\n        else:\r\n            return batch_code\r\n            \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error generating batch code: {str(e)}\", \"Batch AMB Code Generation\")\r\n        return doc.name\r\n\r\ndef validate_batch_code(doc):\r\n    \"\"\"Validate that batch code follows AMB format\"\"\"\r\n    if not doc.custom_generated_batch_name:\r\n        return\r\n    \r\n    # Check for duplicate batch codes\r\n    filters = {\"custom_generated_batch_name\": doc.custom_generated_batch_name}\r\n    if not doc.is_new():\r\n        filters[\"name\"] = [\"!=\", doc.name]\r\n    \r\n    existing = frappe.get_all(\"Batch AMB\", filters=filters, limit=1)\r\n    \r\n    if existing:\r\n        frappe.throw(_(\"Batch code {0} already exists\").format(doc.custom_generated_batch_name))\r\n\r\ndef update_tree_structure(doc):\r\n    \"\"\"Handle custom tree structure updates for string-based lft/rgt\"\"\"\r\n    global amb_updating_nsm\r\n    \r\n    if amb_updating_nsm:\r\n        return\r\n        \r\n    try:\r\n        amb_updating_nsm = True\r\n        \r\n        if doc.is_new():\r\n            # New document - position it in the tree\r\n            position_new_node(doc)\r\n        else:\r\n            # Existing document - check if parent changed\r\n            old_parent = getattr(doc, \"_doc_before_save\", {}).get(\"parent_batch_amb\")\r\n            new_parent = doc.parent_batch_amb\r\n            \r\n            if old_parent != new_parent:\r\n                # Parent changed, need to rebuild tree\r\n                frappe.enqueue(rebuild_tree, doctype=\"Batch AMB\", parent_field=\"parent_batch_amb\")\r\n                \r\n    finally:\r\n        amb_updating_nsm = False\r\n\r\ndef position_new_node(doc):\r\n    \"\"\"Position a new node in the tree structure\"\"\"\r\n    if doc.parent_batch_amb:\r\n        # Child node - position after parent's right value\r\n        parent = frappe.get_doc(\"Batch AMB\", doc.parent_batch_amb)\r\n        if parent.rgt and parent.rgt.isdigit():\r\n            parent_rgt = int(parent.rgt)\r\n            doc.lft = str(parent_rgt).zfill(4)\r\n            doc.rgt = str(parent_rgt + 1).zfill(5)\r\n    else:\r\n        # Root node - find max right value and add after it\r\n        max_rgt = frappe.db.sql(\"\"\"\r\n            SELECT MAX(CAST(rgt AS UNSIGNED)) \r\n            FROM `tabBatch AMB` \r\n            WHERE ifnull(parent_batch_amb, '') = ''\r\n        \"\"\")\r\n        \r\n        max_rgt_val = max_rgt[0][0] if max_rgt and max_rgt[0][0] else 0\r\n        doc.lft = str(max_rgt_val + 1).zfill(4)\r\n        doc.rgt = str(max_rgt_val + 2).zfill(5)\r\n\r\n# Additional server script for After Save event\r\ndef on_update(doc, method):\r\n    \"\"\"Handle after save events\"\"\"\r\n    # Clear cache to refresh tree views\r\n    frappe.clear_cache(doctype=\"Batch AMB\")\r\n    \r\n    # Update parent's is_group flag if needed\r\n    if doc.parent_batch_amb:\r\n        update_parent_is_group(doc.parent_batch_amb)\r\n\r\ndef on_trash(doc, method):\r\n    \"\"\"Handle before delete events\"\"\"\r\n    # Check if batch has children\r\n    if has_child_batches(doc.name):\r\n        frappe.throw(_(\"Cannot delete batch {0} because it has child batches\").format(doc.name))\r\n    \r\n    # Update parent's is_group flag if this was the last child\r\n    if doc.parent_batch_amb:\r\n        update_parent_is_group(doc.parent_batch_amb, exclude_doc=doc.name)\r\n\r\ndef has_child_batches(batch_name):\r\n    \"\"\"Check if a batch has child batches\"\"\"\r\n    child_batches = frappe.get_all(\r\n        \"Batch AMB\",\r\n        filters={\"parent_batch_amb\": batch_name},\r\n        limit=1\r\n    )\r\n    return len(child_batches) > 0\r\n\r\ndef update_parent_is_group(parent_name, exclude_doc=None):\r\n    \"\"\"Update parent's is_group flag based on whether it has children\"\"\"\r\n    try:\r\n        filters = {\"parent_batch_amb\": parent_name}\r\n        if exclude_doc:\r\n            filters[\"name\"] = [\"!=\", exclude_doc]\r\n        \r\n        remaining_children = frappe.get_all(\"Batch AMB\", filters=filters, limit=1)\r\n        \r\n        parent = frappe.get_doc(\"Batch AMB\", parent_name)\r\n        parent.is_group = 1 if remaining_children else 0\r\n        parent.save(ignore_permissions=True)\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error updating parent is_group: {str(e)}\", \"Batch AMB Update Parent\")\r\n\r\n# Client-side utility functions (whitelisted)\r\n#@frappe.whitelist()\r\ndef get_work_order_details(work_order_name):\r\n    \"\"\"Get Work Order details for client script\"\"\"\r\n    try:\r\n        work_order = frappe.get_doc(\"Work Order\", work_order_name)\r\n        return {\r\n            \"production_item\": work_order.production_item,\r\n            \"item_name\": work_order.item_name,\r\n            \"production_plant_name\": getattr(work_order, \"production_plant_name\", \"\"),\r\n            \"sales_order\": getattr(work_order, \"sales_order\", \"\"),\r\n            \"planned_end_date\": work_order.planned_end_date\r\n        }\r\n    except Exception as e:\r\n        frappe.log_error(f\"Error fetching Work Order details: {str(e)}\", \"Batch AMB Work Order Fetch\")\r\n        return None\r\n\r\n#@frappe.whitelist()\r\ndef get_batch_tree(batch_name):\r\n    \"\"\"Get complete batch hierarchy tree\"\"\"\r\n    def get_children(parent_name):\r\n        children = frappe.get_all(\r\n            \"Batch AMB\",\r\n            filters={\"parent_batch_amb\": parent_name},\r\n            fields=[\"name\", \"title\", \"custom_batch_level\", \"custom_generated_batch_name\", \"is_group\"],\r\n            order_by=\"lft\"\r\n        )\r\n        for child in children:\r\n            child[\"children\"] = get_children(child[\"name\"])\r\n        return children\r\n    \r\n    try:\r\n        root_batch = frappe.get_doc(\"Batch AMB\", batch_name)\r\n        \r\n        # If this is not a root batch, find the root\r\n        while root_batch.parent_batch_amb:\r\n            root_batch = frappe.get_doc(\"Batch AMB\", root_batch.parent_batch_amb)\r\n        \r\n        tree = {\r\n            \"name\": root_batch.name,\r\n            \"title\": root_batch.title,\r\n            \"level\": root_batch.custom_batch_level,\r\n            \"batch_code\": root_batch.custom_generated_batch_name,\r\n            \"is_group\": root_batch.is_group,\r\n            \"children\": get_children(root_batch.name)\r\n        }\r\n        return tree\r\n    except Exception as e:\r\n        frappe.log_error(f\"Error building batch tree: {str(e)}\", \"Batch AMB Tree Build\")\r\n        return None\r\n\r\n#@frappe.whitelist()\r\ndef create_child_batch(parent_batch_name, batch_level=None):\r\n    \"\"\"Create a new child batch\"\"\" \r\n    try:\r\n        parent_batch = frappe.get_doc(\"Batch AMB\", parent_batch_name)\r\n        \r\n        new_batch = frappe.new_doc(\"Batch AMB\")\r\n        new_batch.parent_batch_amb = parent_batch_name\r\n        new_batch.custom_batch_level = str(int(parent_batch.custom_batch_level or \"1\") + 1)\r\n        new_batch.work_order_ref = parent_batch.work_order_ref\r\n        new_batch.production_plant_name = parent_batch.production_plant_name\r\n        new_batch.wo_item_name = parent_batch.wo_item_name\r\n        new_batch.item_to_manufacture = parent_batch.item_to_manufacture\r\n        \r\n        return new_batch.as_dict()\r\n    except Exception as e:\r\n        frappe.log_error(f\"Error creating child batch: {str(e)}\", \"Batch AMB Child Creation\")\r\n        frappe.throw(_(\"Error creating child batch: {0}\").format(str(e)))",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "After Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.739525",
  "module": "amb_w_tds",
  "name": "Batch AMB After Save",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "#import frappe\r\n#from frappe import _\r\n#from frappe.utils import getdate, add_years\r\n#from frappe.utils.nestedset import rebuild_tree\r\n\r\n# Global flag to prevent recursion\r\namb_updating_nsm = False\r\n\r\ndef on_update(doc, method):\r\n    \"\"\"Handle after save events\"\"\"\r\n    global amb_updating_nsm\r\n    \r\n    # Prevent recursion\r\n    if amb_updating_nsm:\r\n        return\r\n        \r\n    amb_updating_nsm = True\r\n    \r\n    try:\r\n        # Update parent's is_group flag if needed\r\n        if doc.parent_batch_amb:\r\n            update_parent_is_group(doc.parent_batch_amb)\r\n            \r\n        # Rebuild tree if necessary (be cautious as this is heavy operation)\r\n        # rebuild_tree(\"Batch AMB\")\r\n        \r\n    finally:\r\n        amb_updating_nsm = False\r\n        # Don't clear cache here as it can interfere with UI state\r\n\r\ndef update_parent_is_group(parent_name):\r\n    \"\"\"Update parent's is_group flag without triggering full save\"\"\"\r\n    parent = frappe.get_doc(\"Batch AMB\", parent_name)\r\n    if parent and not parent.is_group:\r\n        # Use db_set to update without triggering full document save\r\n        frappe.db.set_value(\"Batch AMB\", parent_name, \"is_group\", 1)\r\n        frappe.db.commit()",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Delete",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.052202",
  "module": "amb_w_tds",
  "name": "Batch AMB Before Delete",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "#import frappe\r\n#from frappe import _\r\n#from frappe.utils import getdate, add_years\r\n#from frappe.utils.nestedset import rebuild_tree\r\n\r\n# Global flag to prevent recursion\r\namb_updating_nsm = False\r\n\r\n\r\n\r\ndef on_trash(doc, method):\r\n    \"\"\"Handle before delete events\"\"\"\r\n    # Check if batch has children\r\n    if has_child_batches(doc.name):\r\n        frappe.throw(_(\"Cannot delete batch {0} because it has child batches\").format(doc.name))\r\n    \r\n    # Update parent's is_group flag if this was the last child\r\n    if doc.parent_batch_amb:\r\n        update_parent_is_group(doc.parent_batch_amb, exclude_doc=doc.name)\r\n\r\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.062511",
  "module": "amb_w_tds",
  "name": "Disable Batch AMB NestedSet",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "#import frappe\r\n#from frappe import _\r\n\r\ndef validate(doc, method):\r\n    \"\"\"Disable standard nestedset behavior and handle tree manually\"\"\"\r\n    \r\n    # Prevent the standard nestedset on_update from running\r\n    if hasattr(doc, 'amb_disable_nestedset'):\r\n        return\r\n        \r\n    doc.amb_disable_nestedset = True\r\n    \r\n    # Ensure lft and rgt are properly formatted strings\r\n    ensure_string_formats(doc)\r\n    \r\n    # Handle tree positioning for new documents\r\n    if doc.is_new():\r\n        position_new_node(doc)\r\n    \r\n    # Auto-generate fields\r\n    auto_generate_fields(doc)\r\n    \r\n    # Validate hierarchy\r\n    validate_batch_hierarchy(doc)\r\n\r\ndef ensure_string_formats(doc):\r\n    \"\"\"Ensure lft and rgt maintain string format with leading zeros\"\"\" \r\n    if doc.lft is None or doc.lft == \"\":\r\n        doc.lft = \"0001\"\r\n    elif isinstance(doc.lft, int):\r\n        doc.lft = str(doc.lft).zfill(4)\r\n    elif isinstance(doc.lft, str) and doc.lft.isdigit():\r\n        doc.lft = doc.lft.zfill(4)\r\n    \r\n    if doc.rgt is None or doc.rgt == \"\":\r\n        doc.rgt = \"0002\"\r\n    elif isinstance(doc.rgt, int):\r\n        doc.rgt = str(doc.rgt).zfill(5)\r\n    elif isinstance(doc.rgt, str) and doc.rgt.isdigit():\r\n        doc.rgt = doc.rgt.zfill(5)\r\n\r\ndef position_new_node(doc):\r\n    \"\"\"Position a new node in the tree structure\"\"\"\r\n    if doc.parent_batch_amb:\r\n        # Child node - get parent's right value and increment\r\n        try:\r\n            parent = frappe.get_doc(\"Batch AMB\", doc.parent_batch_amb)\r\n            if parent.rgt and parent.rgt.isdigit():\r\n                parent_rgt = int(parent.rgt)\r\n                doc.lft = str(parent_rgt).zfill(4)\r\n                doc.rgt = str(parent_rgt + 1).zfill(5)\r\n                \r\n                # Update parent's right value\r\n                parent.rgt = str(parent_rgt + 2).zfill(5)\r\n                parent.save(ignore_permissions=True)\r\n        except frappe.DoesNotExistError:\r\n            frappe.throw(_(\"Parent batch {0} does not exist\").format(doc.parent_batch_amb))\r\n    else:\r\n        # Root node - find max right value\r\n        max_rgt = frappe.db.sql(\"\"\"\r\n            SELECT MAX(CAST(rgt AS UNSIGNED)) \r\n            FROM `tabBatch AMB` \r\n            WHERE ifnull(parent_batch_amb, '') = ''\r\n        \"\"\")\r\n        \r\n        max_rgt_val = max_rgt[0][0] if max_rgt and max_rgt[0][0] else 0\r\n        doc.lft = str(max_rgt_val + 1).zfill(4)\r\n        doc.rgt = str(max_rgt_val + 2).zfill(5)\r\n\r\ndef auto_generate_fields(doc):\r\n    \"\"\"Auto-generate required fields\"\"\"\r\n    if not doc.consecutive_number:\r\n        doc.consecutive_number = get_next_consecutive_number(doc)\r\n    \r\n    if not doc.custom_generated_batch_name:\r\n        doc.custom_generated_batch_name = generate_batch_code(doc)\r\n    \r\n    if doc.custom_generated_batch_name:\r\n        doc.title = doc.custom_generated_batch_name\r\n    \r\n    if not doc.expiry_date:\r\n        from frappe.utils import add_years, getdate\r\n        doc.expiry_date = add_years(getdate(), 2)\r\n    \r\n    # Set is_group based on level\r\n    level = int(doc.custom_batch_level or \"1\")\r\n    doc.is_group = 1 if level < 4 else 0\r\n\r\ndef get_next_consecutive_number(doc):\r\n    \"\"\"Get next consecutive number\"\"\"\r\n    filters = {\"custom_batch_level\": doc.custom_batch_level}\r\n    \r\n    if doc.parent_batch_amb:\r\n        filters[\"parent_batch_amb\"] = doc.parent_batch_amb\r\n    else:\r\n        filters[\"parent_batch_amb\"] = [\"is\", \"not set\"]\r\n    \r\n    existing = frappe.get_all(\"Batch AMB\", filters=filters, \r\n                            fields=[\"consecutive_number\"],\r\n                            order_by=\"consecutive_number desc\", \r\n                            limit=1)\r\n    \r\n    return int(existing[0].consecutive_number) + 1 if existing and existing[0].consecutive_number else 1\r\n\r\ndef generate_batch_code(doc):\r\n    \"\"\"Generate batch code\"\"\"\r\n    try:\r\n        plant_code = str(doc.production_plant_name)[0].upper() if doc.production_plant_name else \"X\"\r\n        consecutive = str(doc.consecutive_number).zfill(3)\r\n        lft_str = str(doc.lft or \"0000\").zfill(4)\r\n        rgt_str = str(doc.rgt or \"00000\").zfill(5)\r\n        \r\n        batch_code = f\"{lft_str}{rgt_str}{plant_code}{consecutive}\"\r\n        \r\n        level = doc.custom_batch_level or \"1\"\r\n        if level == \"2\":\r\n            return f\"{batch_code}-S{doc.consecutive_number}\"\r\n        elif level == \"3\":\r\n            return f\"{batch_code}-C{str(doc.consecutive_number).zfill(3)}\"\r\n        elif level == \"4\":\r\n            return f\"{batch_code}-P{doc.consecutive_number}\"\r\n        else:\r\n            return batch_code\r\n            \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error generating batch code: {str(e)}\")\r\n        return doc.name\r\n\r\ndef validate_batch_hierarchy(doc):\r\n    \"\"\"Validate batch hierarchy\"\"\"\r\n    if not doc.custom_batch_level:\r\n        doc.custom_batch_level = \"1\"\r\n    \r\n    level = int(doc.custom_batch_level)\r\n    \r\n    if level > 1 and not doc.parent_batch_amb:\r\n        frappe.throw(_(\"Parent Batch AMB is required for batch level {0}\").format(level))\r\n    \r\n    if doc.parent_batch_amb:\r\n        try:\r\n            parent = frappe.get_doc(\"Batch AMB\", doc.parent_batch_amb)\r\n            parent_level = int(parent.custom_batch_level or \"1\")\r\n            \r\n            if level != parent_level + 1:\r\n                frappe.throw(_(\"Batch level must be one level below parent. Parent level: {0}, Current level: {1}\").format(parent_level, level))\r\n                \r\n        except frappe.DoesNotExistError:\r\n            frappe.throw(_(\"Parent batch {0} does not exist\").format(doc.parent_batch_amb))",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.116683",
  "module": "amb_w_tds",
  "name": "Batch AMB Tree Handler",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "import frappe\r\nfrom frappe import _\r\nfrom frappe.utils import getdate, add_years\r\n\r\ndef validate(doc, method):\r\n    \"\"\"Handle Batch AMB tree structure with string-based lft/rgt\"\"\"\r\n    \r\n    # Skip if already processing or during install/migrate\r\n    if frappe.flags.in_install or frappe.flags.in_migrate:\r\n        return\r\n        \r\n    # Set flag to prevent standard nestedset processing\r\n    frappe.flags.batch_amb_processing = True\r\n    \r\n    try:\r\n        # Ensure lft and rgt are properly formatted strings\r\n        ensure_string_formats(doc)\r\n        \r\n        # Handle tree positioning for new documents\r\n        if doc.is_new():\r\n            position_new_node(doc)\r\n        \r\n        # Auto-generate fields\r\n        auto_generate_fields(doc)\r\n        \r\n        # Validate hierarchy\r\n        validate_batch_hierarchy(doc)\r\n        \r\n    finally:\r\n        # Clear the flag\r\n        frappe.flags.batch_amb_processing = False\r\n\r\ndef ensure_string_formats(doc):\r\n    \"\"\"Ensure lft and rgt maintain string format with leading zeros\"\"\"\r\n    if doc.lft is None or doc.lft == \"\":\r\n        doc.lft = \"0001\"\r\n    elif isinstance(doc.lft, int):\r\n        doc.lft = str(doc.lft).zfill(4)\r\n    elif isinstance(doc.lft, str) and doc.lft.isdigit():\r\n        doc.lft = doc.lft.zfill(4)\r\n    \r\n    if doc.rgt is None or doc.rgt == \"\":\r\n        doc.rgt = \"0002\"\r\n    elif isinstance(doc.rgt, int):\r\n        doc.rgt = str(doc.rgt).zfill(5)\r\n    elif isinstance(doc.rgt, str) and doc.rgt.isdigit():\r\n        doc.rgt = doc.rgt.zfill(5)\r\n\r\ndef position_new_node(doc):\r\n    \"\"\"Position a new node in the tree structure\"\"\"\r\n    if doc.parent_batch_amb:\r\n        # Child node - position after parent\r\n        try:\r\n            parent = frappe.get_doc(\"Batch AMB\", doc.parent_batch_amb)\r\n            if parent.rgt and parent.rgt.isdigit():\r\n                parent_rgt = int(parent.rgt)\r\n                doc.lft = str(parent_rgt).zfill(4)\r\n                doc.rgt = str(parent_rgt + 1).zfill(5)\r\n        except frappe.DoesNotExistError:\r\n            frappe.throw(_(\"Parent batch {0} does not exist\").format(doc.parent_batch_amb))\r\n    else:\r\n        # Root node - find max right value\r\n        max_rgt = frappe.db.sql(\"\"\"\r\n            SELECT MAX(CAST(rgt AS UNSIGNED)) \r\n            FROM `tabBatch AMB` \r\n            WHERE ifnull(parent_batch_amb, '') = ''\r\n        \"\"\")\r\n        \r\n        max_rgt_val = max_rgt[0][0] if max_rgt and max_rgt[0][0] else 0\r\n        doc.lft = str(max_rgt_val + 1).zfill(4)\r\n        doc.rgt = str(max_rgt_val + 2).zfill(5)\r\n\r\ndef auto_generate_fields(doc):\r\n    \"\"\"Auto-generate required fields\"\"\"\r\n    if not doc.consecutive_number:\r\n        doc.consecutive_number = get_next_consecutive_number(doc)\r\n    \r\n    if not doc.custom_generated_batch_name:\r\n        doc.custom_generated_batch_name = generate_batch_code(doc)\r\n    \r\n    if doc.custom_generated_batch_name:\r\n        doc.title = doc.custom_generated_batch_name\r\n    \r\n    if not doc.expiry_date:\r\n        doc.expiry_date = add_years(getdate(), 2)\r\n    \r\n    # Set is_group based on level\r\n    level = int(doc.custom_batch_level or \"1\")\r\n    doc.is_group = 1 if level < 4 else 0\r\n\r\ndef get_next_consecutive_number(doc):\r\n    \"\"\"Get next consecutive number\"\"\"\r\n    filters = {\"custom_batch_level\": doc.custom_batch_level}\r\n    \r\n    if doc.parent_batch_amb:\r\n        filters[\"parent_batch_amb\"] = doc.parent_batch_amb\r\n    else:\r\n        filters[\"parent_batch_amb\"] = [\"is\", \"not set\"]\r\n    \r\n    existing = frappe.get_all(\"Batch AMB\", filters=filters, \r\n                            fields=[\"consecutive_number\"],\r\n                            order_by=\"consecutive_number desc\", \r\n                            limit=1)\r\n    \r\n    if existing and existing[0].consecutive_number:\r\n        return int(existing[0].consecutive_number) + 1\r\n    else:\r\n        return 1\r\n\r\ndef generate_batch_code(doc):\r\n    \"\"\"Generate batch code\"\"\"\r\n    try:\r\n        plant_code = str(doc.production_plant_name)[0].upper() if doc.production_plant_name else \"X\"\r\n        consecutive = str(doc.consecutive_number).zfill(3)\r\n        lft_str = str(doc.lft or \"0000\").zfill(4)\r\n        rgt_str = str(doc.rgt or \"00000\").zfill(5)\r\n        \r\n        batch_code = f\"{lft_str}{rgt_str}{plant_code}{consecutive}\"\r\n        \r\n        level = doc.custom_batch_level or \"1\"\r\n        if level == \"2\":\r\n            return f\"{batch_code}-S{doc.consecutive_number}\"\r\n        elif level == \"3\":\r\n            return f\"{batch_code}-C{str(doc.consecutive_number).zfill(3)}\"\r\n        elif level == \"4\":\r\n            return f\"{batch_code}-P{doc.consecutive_number}\"\r\n        else:\r\n            return batch_code\r\n            \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error generating batch code: {str(e)}\")\r\n        return doc.name\r\n\r\ndef validate_batch_hierarchy(doc):\r\n    \"\"\"Validate batch hierarchy\"\"\"\r\n    if not doc.custom_batch_level:\r\n        doc.custom_batch_level = \"1\"\r\n    \r\n    level = int(doc.custom_batch_level)\r\n    \r\n    if level > 1 and not doc.parent_batch_amb:\r\n        frappe.throw(_(\"Parent Batch AMB is required for batch level {0}\").format(level))\r\n    \r\n    if doc.parent_batch_amb:\r\n        try:\r\n            parent = frappe.get_doc(\"Batch AMB\", doc.parent_batch_amb)\r\n            parent_level = int(parent.custom_batch_level or \"1\")\r\n            \r\n            if level != parent_level + 1:\r\n                frappe.throw(_(\"Batch level must be one level below parent. Parent level: {0}, Current level: {1}\").format(parent_level, level))\r\n                \r\n        except frappe.DoesNotExistError:\r\n            frappe.throw(_(\"Parent batch {0} does not exist\").format(doc.parent_batch_amb))",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": "prevent_nestedset",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.836317",
  "module": "amb_w_tds",
  "name": "Prevent NestedSet Processing",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "#import frappe\r\n#from frappe.model.base_document import BaseDocument\r\n\r\n#@frappe.whitelist()\r\ndef prevent_nestedset():\r\n    \"\"\"Monkey patch to prevent standard nestedset processing for Batch AMB\"\"\"\r\n    \r\n    original_on_update = None\r\n    \r\n    def custom_on_update(self):\r\n        \"\"\"Custom on_update that skips nestedset for Batch AMB\"\"\"\r\n        if (hasattr(self, 'doctype') and self.doctype == \"Batch AMB\" and \r\n            hasattr(frappe.flags, 'batch_amb_processing') and frappe.flags.batch_amb_processing):\r\n            # Skip standard nestedset processing\r\n            return\r\n            \r\n        # Call original on_update for other doctypes\r\n        if original_on_update:\r\n            return original_on_update(self)\r\n    \r\n    # Store original method and replace it\r\n    if hasattr(BaseDocument, 'on_update'):\r\n        original_on_update = BaseDocument.on_update\r\n        BaseDocument.on_update = custom_on_update\r\n    \r\n    return \"NestedSet prevention applied\"\r\n\r\n\r\ndef execute():\r\n    \"\"\"\r\n    Patch to fix lft and rgt fields that are stored as strings in Batch AMB\r\n    \"\"\"\r\n    # Fix lft and rgt fields that are stored as strings\r\n    batches = frappe.get_all('Batch AMB', fields=['name', 'lft', 'rgt'])\r\n    \r\n    updated_count = 0\r\n    \r\n    for batch in batches:\r\n        update_needed = False\r\n        updates = {}\r\n        \r\n        if batch.lft and isinstance(batch.lft, str):\r\n            try:\r\n                updates['lft'] = int(batch.lft)\r\n                update_needed = True\r\n            except (ValueError, TypeError):\r\n                updates['lft'] = 0\r\n                update_needed = True\r\n        \r\n        if batch.rgt and isinstance(batch.rgt, str):\r\n            try:\r\n                updates['rgt'] = int(batch.rgt)\r\n                update_needed = True\r\n            except (ValueError, TypeError):\r\n                updates['rgt'] = 0\r\n                update_needed = True\r\n        \r\n        if update_needed:\r\n            frappe.db.set_value('Batch AMB', batch.name, updates)\r\n            updated_count += 1\r\n    \r\n    frappe.msgprint(f\"Fixed {updated_count} Batch AMB records with string lft/rgt values\")",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "batch_amb_custom_tree_api",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.804383",
  "module": "amb_w_tds",
  "name": "Batch AMB Custom Tree API",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "#import frappe\r\n#from frappe import _\r\n#import json\r\n#import re\r\n\r\ndef before_insert(self, method):\r\n    \"\"\"Set up parent relationship before insert\"\"\"\r\n    if self.custom_batch_level and int(self.custom_batch_level) > 1:\r\n        if not self.parent_batch_amb:\r\n            frappe.throw(_(\"Parent Batch AMB is required for level {0}\").format(self.custom_batch_level))\r\n        \r\n        # Ensure parent field is set for nested set to work properly\r\n        if not hasattr(self, 'parent'):\r\n            self.parent = self.parent_batch_amb\r\n\r\ndef before_save(self, method):\r\n    \"\"\"Validate data before saving\"\"\"\r\n    # Validate batch level and parent relationship\r\n    if self.custom_batch_level and int(self.custom_batch_level) > 1:\r\n        if not self.parent_batch_amb:\r\n            frappe.throw(_(\"Parent Batch AMB is required for level {0}\").format(self.custom_batch_level))\r\n    \r\n    # Ensure numeric fields are properly typed (prevent string concatenation errors)\r\n    if self.custom_plant_code:\r\n        try:\r\n            self.custom_plant_code = int(self.custom_plant_code)\r\n        except (ValueError, TypeError):\r\n            pass\r\n    \r\n    if self.custom_sublot_consecutive:\r\n        try:\r\n            self.custom_sublot_consecutive = int(self.custom_sublot_consecutive)\r\n        except (ValueError, TypeError):\r\n            pass\r\n    \r\n    # Validate barrel data for Level 3 containers\r\n    if self.custom_batch_level == '3' and self.container_barrels:\r\n        validate_container_barrel_data(self)\r\n    \r\n    # Never manually set lft/rgt - let Frappe handle them\r\n    if hasattr(self, 'lft') and self.lft is not None and not isinstance(self.lft, (int, float)):\r\n        self.lft = None\r\n    if hasattr(self, 'rgt') and self.rgt is not None and not isinstance(self.rgt, (int, float)):\r\n        self.rgt = None\r\n\r\ndef on_update(self, method):\r\n    \"\"\"Called after document is saved\"\"\"\r\n    # Update weight totals for Level 3 containers\r\n    if self.custom_batch_level == '3' and self.container_barrels:\r\n        calculate_container_weight_totals(self)\r\n    \r\n    # Let the parent class handle nested set updates\r\n    # Don't interfere with lft/rgt calculations\r\n    pass\r\n\r\ndef validate(self, method):\r\n    \"\"\"Validate the document\"\"\"\r\n    # Ensure title is set\r\n    if not self.title and self.custom_generated_batch_name:\r\n        self.title = self.custom_generated_batch_name\r\n    \r\n    # Set is_group based on level\r\n    if self.custom_batch_level:\r\n        level = int(self.custom_batch_level)\r\n        if level in [1, 2, 3]:  # Levels 1-3 are groups\r\n            self.is_group = 1\r\n        else:  # Level 4 and beyond are not groups\r\n            self.is_group = 0\r\n    \r\n    # Validate barrel serial number uniqueness for Level 3\r\n    if self.custom_batch_level == '3' and self.container_barrels:\r\n        validate_barrel_serial_uniqueness(self)\r\n\r\ndef validate_container_barrel_data(self):\r\n    \"\"\"Validate barrel data in container\"\"\"\r\n    if not self.container_barrels:\r\n        return\r\n    \r\n    for idx, barrel in enumerate(self.container_barrels):\r\n        row_num = idx + 1\r\n        \r\n        # Validate required fields\r\n        if barrel.barrel_serial_number and not barrel.gross_weight:\r\n            frappe.throw(_(\"Row {0}: Gross weight is required for barrel {1}\").format(\r\n                row_num, barrel.barrel_serial_number\r\n            ))\r\n        \r\n        if barrel.gross_weight and not barrel.packaging_type:\r\n            frappe.throw(_(\"Row {0}: Packaging type is required when gross weight is entered\").format(row_num))\r\n        \r\n        # Validate weight calculations\r\n        if barrel.gross_weight and barrel.tara_weight:\r\n            calculated_net = barrel.gross_weight - barrel.tara_weight\r\n            \r\n            if calculated_net <= 0:\r\n                frappe.throw(_(\"Row {0}: Net weight cannot be zero or negative for barrel {1}\").format(\r\n                    row_num, barrel.barrel_serial_number\r\n                ))\r\n            \r\n            # Auto-calculate net weight if not set or different\r\n            if not barrel.net_weight or abs(barrel.net_weight - calculated_net) > 0.001:\r\n                barrel.net_weight = calculated_net\r\n        \r\n        # Validate CODE-39 barcode format\r\n        if barrel.barrel_serial_number and not validate_code39_barcode(barrel.barrel_serial_number):\r\n            frappe.throw(_(\"Row {0}: Invalid CODE-39 barcode format for barrel {1}\").format(\r\n                row_num, barrel.barrel_serial_number\r\n            ))\r\n\r\ndef validate_barrel_serial_uniqueness(self):\r\n    \"\"\"Ensure barrel serial numbers are unique within the container\"\"\"\r\n    if not self.container_barrels:\r\n        return\r\n    \r\n    seen_serials = set()\r\n    \r\n    for idx, barrel in enumerate(self.container_barrels):\r\n        if barrel.barrel_serial_number:\r\n            if barrel.barrel_serial_number in seen_serials:\r\n                frappe.throw(_(\"Duplicate barrel serial number: {0} (Row {1})\").format(\r\n                    barrel.barrel_serial_number, idx + 1\r\n                ))\r\n            seen_serials.add(barrel.barrel_serial_number)\r\n    \r\n    # Check for duplicates across other containers in the system\r\n    if seen_serials:\r\n        existing_serials = frappe.db.sql(\"\"\"\r\n            SELECT cb.barrel_serial_number, ba.name as container_name\r\n            FROM `tabContainer Barrels` cb\r\n            INNER JOIN `tabBatch AMB` ba ON cb.parent = ba.name\r\n            WHERE cb.barrel_serial_number IN %(serials)s\r\n            AND ba.name != %(current_doc)s\r\n        \"\"\", {\r\n            'serials': list(seen_serials),\r\n            'current_doc': self.name or 'new'\r\n        }, as_dict=True)\r\n        \r\n        if existing_serials:\r\n            duplicate_info = \", \".join([\r\n                f\"{row['barrel_serial_number']} (in {row['container_name']})\"\r\n                for row in existing_serials\r\n            ])\r\n            frappe.throw(_(\"Barrel serial numbers already exist in other containers: {0}\").format(duplicate_info))\r\n\r\ndef calculate_container_weight_totals(self):\r\n    \"\"\"Calculate and update weight totals for the container\"\"\"\r\n    if not self.container_barrels:\r\n        return\r\n    \r\n    total_gross = 0.0\r\n    total_tara = 0.0\r\n    total_net = 0.0\r\n    barrel_count = 0\r\n    \r\n    for barrel in self.container_barrels:\r\n        if barrel.gross_weight:\r\n            total_gross = total_gross + float(barrel.gross_weight)\r\n        if barrel.tara_weight:\r\n            total_tara = total_tara + float(barrel.tara_weight)\r\n        if barrel.net_weight:\r\n            total_net = total_net + float(barrel.net_weight)\r\n        if barrel.barrel_serial_number:\r\n            barrel_count = barrel_count + 1\r\n    \r\n    # Update totals\r\n    self.total_gross_weight = total_gross\r\n    self.total_tara_weight = total_tara\r\n    self.total_net_weight = total_net\r\n    self.barrel_count = barrel_count\r\n    \r\n    # Update in database if document is saved\r\n    if not self.is_new():\r\n        frappe.db.set_value('Batch AMB', self.name, {\r\n            'total_gross_weight': total_gross,\r\n            'total_tara_weight': total_tara,\r\n            'total_net_weight': total_net,\r\n            'barrel_count': barrel_count\r\n        })\r\n\r\ndef validate_code39_barcode(barcode):\r\n    \"\"\"Validate CODE-39 barcode format\"\"\"\r\n    if not barcode:\r\n        return False\r\n    \r\n    # CODE-39 allows alphanumeric characters and specific symbols\r\n    return re.match(r'^[A-Z0-9\\-\\\\.\\s\\$\\/\\+\\%\\\\*]+$', barcode.upper()) is not None\r\n\r\n# API Methods for client script support\r\n\r\n@frappe.whitelist()\r\ndef get_packaging_item_weight(item_code):\r\n    \"\"\"Get tara weight for packaging item\"\"\"\r\n    if not item_code:\r\n        return {\"weight_per_unit\": 0}\r\n    \r\n    item = frappe.get_doc(\"Item\", item_code)\r\n    return {\r\n        \"weight_per_unit\": item.weight_per_unit or 0,\r\n        \"item_name\": item.item_name,\r\n        \"uom\": item.weight_uom or \"Kg\"\r\n    }\r\n\r\n@frappe.whitelist()\r\ndef get_packaging_items():\r\n    \"\"\"Get list of packaging items (E0% items)\"\"\"\r\n    items = frappe.get_all(\"Item\", \r\n        filters={\r\n            \"item_code\": [\"like\", \"E0%\"],\r\n            \"disabled\": 0\r\n        },\r\n        fields=[\"name\", \"item_name\", \"weight_per_unit\", \"weight_uom\"]\r\n    )\r\n    return items\r\n\r\n@frappe.whitelist()\r\ndef validate_barrel_serial_number(serial_number, container_name=None):\r\n    \"\"\"Check if barrel serial number already exists\"\"\"\r\n    if not serial_number:\r\n        return {\"valid\": True}\r\n    \r\n    filters = {\r\n        \"barrel_serial_number\": serial_number\r\n    }\r\n    \r\n    if container_name:\r\n        filters[\"parent\"] = [\"!=\", container_name]\r\n    \r\n    existing = frappe.get_all(\"Container Barrels\", filters=filters, limit=1)\r\n    \r\n    if existing:\r\n        container_info = frappe.db.get_value(\"Container Barrels\", existing[0].name, \"parent\")\r\n        return {\r\n            \"valid\": False,\r\n            \"message\": f\"Serial number {serial_number} already exists in container {container_info}\"\r\n        }\r\n    \r\n    return {\"valid\": True}\r\n\r\n@frappe.whitelist()\r\ndef bulk_update_tara_weights(container_name, packaging_type):\r\n    \"\"\"Update tara weights for all barrels of a specific packaging type in container\"\"\"\r\n    if not container_name or not packaging_type:\r\n        frappe.throw(_(\"Container name and packaging type are required\"))\r\n    \r\n    # Get packaging item weight\r\n    item_weight = get_packaging_item_weight(packaging_type)\r\n    tara_weight = item_weight.get(\"weight_per_unit\", 0)\r\n    \r\n    if not tara_weight:\r\n        frappe.throw(_(\"No weight found for packaging type {0}\").format(packaging_type))\r\n    \r\n    # Update all matching barrels\r\n    barrels = frappe.get_all(\"Container Barrels\",\r\n        filters={\r\n            \"parent\": container_name,\r\n            \"packaging_type\": packaging_type\r\n        },\r\n        fields=[\"name\"]\r\n    )\r\n    \r\n    updated_count = 0\r\n    for barrel in barrels:\r\n        frappe.db.set_value(\"Container Barrels\", barrel.name, \"tara_weight\", tara_weight)\r\n        updated_count = updated_count + 1\r\n    \r\n    if updated_count > 0:\r\n        # Recalculate net weights\r\n        recalculate_net_weights_for_container(container_name)\r\n        frappe.db.commit()\r\n    \r\n    return {\r\n        \"success\": True,\r\n        \"updated_count\": updated_count,\r\n        \"tara_weight\": tara_weight\r\n    }\r\n\r\n@frappe.whitelist()\r\ndef recalculate_net_weights_for_container(container_name):\r\n    \"\"\"Recalculate net weights for all barrels in a container\"\"\"\r\n    if not container_name:\r\n        return\r\n    \r\n    barrels = frappe.get_all(\"Container Barrels\",\r\n        filters={\"parent\": container_name},\r\n        fields=[\"name\", \"gross_weight\", \"tara_weight\"]\r\n    )\r\n    \r\n    for barrel in barrels:\r\n        if barrel.gross_weight and barrel.tara_weight:\r\n            net_weight = barrel.gross_weight - barrel.tara_weight\r\n            frappe.db.set_value(\"Container Barrels\", barrel.name, \"net_weight\", net_weight)\r\n    \r\n    # Update container totals\r\n    container_doc = frappe.get_doc(\"Batch AMB\", container_name)\r\n    calculate_container_weight_totals(container_doc)\r\n    \r\n    frappe.db.commit()\r\n\r\n@frappe.whitelist()\r\ndef generate_container_report(container_name):\r\n    \"\"\"Generate weight summary report for container\"\"\"\r\n    if not container_name:\r\n        frappe.throw(_(\"Container name is required\"))\r\n    \r\n    container = frappe.get_doc(\"Batch AMB\", container_name)\r\n    \r\n    if container.custom_batch_level != '3':\r\n        frappe.throw(_(\"This function is only for Level 3 containers\"))\r\n    \r\n    # Get barrel details\r\n    barrels = frappe.get_all(\"Container Barrels\",\r\n        filters={\"parent\": container_name},\r\n        fields=[\r\n            \"barrel_serial_number\", \"packaging_type\", \r\n            \"gross_weight\", \"tara_weight\", \"net_weight\",\r\n            \"weight_validated\", \"scan_timestamp\", \"notes\"\r\n        ],\r\n        order_by=\"barrel_serial_number\"\r\n    )\r\n    \r\n    # Calculate statistics\r\n    total_barrels = len(barrels)\r\n    validated_barrels = sum(1 for b in barrels if b.weight_validated)\r\n    avg_net_weight = sum(b.net_weight or 0 for b in barrels) / max(total_barrels, 1)\r\n    \r\n    # Group by packaging type\r\n    packaging_summary = {}\r\n    for barrel in barrels:\r\n        pkg_type = barrel.packaging_type or \"Unknown\"\r\n        if pkg_type not in packaging_summary:\r\n            packaging_summary[pkg_type] = {\r\n                \"count\": 0,\r\n                \"total_gross\": 0,\r\n                \"total_tara\": 0,\r\n                \"total_net\": 0\r\n            }\r\n        \r\n        summary = packaging_summary[pkg_type]\r\n        summary[\"count\"] = summary[\"count\"] + 1\r\n        summary[\"total_gross\"] = summary[\"total_gross\"] + (barrel.gross_weight or 0)\r\n        summary[\"total_tara\"] = summary[\"total_tara\"] + (barrel.tara_weight or 0)\r\n        summary[\"total_net\"] = summary[\"total_net\"] + (barrel.net_weight or 0)\r\n    \r\n    return {\r\n        \"container_info\": {\r\n            \"name\": container.name,\r\n            \"title\": container.title,\r\n            \"level\": container.custom_batch_level,\r\n            \"parent\": container.parent_batch_amb\r\n        },\r\n        \"summary\": {\r\n            \"total_barrels\": total_barrels,\r\n            \"validated_barrels\": validated_barrels,\r\n            \"total_gross_weight\": container.total_gross_weight or 0,\r\n            \"total_tara_weight\": container.total_tara_weight or 0,\r\n            \"total_net_weight\": container.total_net_weight or 0,\r\n            \"average_net_weight\": round(avg_net_weight, 3)\r\n        },\r\n        \"packaging_summary\": packaging_summary,\r\n        \"barrels\": barrels\r\n    }",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.078054",
  "module": "amb_w_tds",
  "name": "Batch AMB Tree Handler2",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "#import frappe\r\n#from frappe import _\r\n#from frappe.utils import getdate, add_years\r\n\r\ndef validate(doc, method):\r\n    \"\"\"Handle Batch AMB tree structure with string-based lft/rgt\"\"\"\r\n    \r\n    # Skip during install/migrate\r\n    if frappe.flags.in_install or frappe.flags.in_migrate:\r\n        return\r\n        \r\n    # Set flag to prevent standard nestedset processing\r\n    frappe.flags.batch_amb_processing = True\r\n    \r\n    try:\r\n        # Ensure lft and rgt are properly formatted strings\r\n        if not doc.lft or doc.lft == \"\":\r\n            doc.lft = \"0001\"\r\n        elif isinstance(doc.lft, int):\r\n            doc.lft = str(doc.lft).zfill(4)\r\n        \r\n        if not doc.rgt or doc.rgt == \"\":\r\n            doc.rgt = \"0002\"\r\n        elif isinstance(doc.rgt, int):\r\n            doc.rgt = str(doc.rgt).zfill(5)\r\n        \r\n        # Handle tree positioning for new documents\r\n        if doc.is_new():\r\n            position_new_node(doc)\r\n        \r\n        # Auto-generate fields\r\n        auto_generate_fields(doc)\r\n        \r\n        # Validate hierarchy\r\n        validate_batch_hierarchy(doc)\r\n        \r\n    finally:\r\n        # Clear the flag\r\n        frappe.flags.batch_amb_processing = False\r\n\r\ndef position_new_node(doc):\r\n    \"\"\"Position a new node in the tree structure\"\"\"\r\n    if doc.parent_batch_amb:\r\n        # Child node - position after parent\r\n        try:\r\n            parent = frappe.get_doc(\"Batch AMB\", doc.parent_batch_amb)\r\n            if parent.rgt and str(parent.rgt).isdigit():\r\n                parent_rgt = int(parent.rgt)\r\n                doc.lft = str(parent_rgt).zfill(4)\r\n                doc.rgt = str(parent_rgt + 1).zfill(5)\r\n        except frappe.DoesNotExistError:\r\n            frappe.throw(_(\"Parent batch {0} does not exist\").format(doc.parent_batch_amb))\r\n    else:\r\n        # Root node - find max right value\r\n        max_rgt = frappe.db.sql(\"\"\"\r\n            SELECT MAX(CAST(rgt AS UNSIGNED)) \r\n            FROM `tabBatch AMB` \r\n            WHERE ifnull(parent_batch_amb, '') = ''\r\n        \"\"\")\r\n        \r\n        max_rgt_val = max_rgt[0][0] if max_rgt and max_rgt[0][0] else 0\r\n        doc.lft = str(max_rgt_val + 1).zfill(4)\r\n        doc.rgt = str(max_rgt_val + 2).zfill(5)\r\n\r\ndef auto_generate_fields(doc):\r\n    \"\"\"Auto-generate required fields\"\"\"\r\n    if not doc.consecutive_number:\r\n        doc.consecutive_number = get_next_consecutive_number(doc)\r\n    \r\n    if not doc.custom_generated_batch_name:\r\n        doc.custom_generated_batch_name = generate_batch_code(doc)\r\n    \r\n    if doc.custom_generated_batch_name:\r\n        doc.title = doc.custom_generated_batch_name\r\n    \r\n    if not doc.expiry_date:\r\n        doc.expiry_date = add_years(getdate(), 2)\r\n    \r\n    # Set is_group based on level\r\n    level = int(doc.custom_batch_level or \"1\")\r\n    doc.is_group = 1 if level < 4 else 0\r\n\r\ndef get_next_consecutive_number(doc):\r\n    \"\"\"Get next consecutive number\"\"\"\r\n    filters = {\"custom_batch_level\": doc.custom_batch_level}\r\n    \r\n    if doc.parent_batch_amb:\r\n        filters[\"parent_batch_amb\"] = doc.parent_batch_amb\r\n    else:\r\n        filters[\"parent_batch_amb\"] = [\"is\", \"not set\"]\r\n    \r\n    existing = frappe.get_all(\"Batch AMB\", filters=filters, \r\n                            fields=[\"consecutive_number\"],\r\n                            order_by=\"consecutive_number desc\", \r\n                            limit=1)\r\n    \r\n    if existing and existing[0].consecutive_number:\r\n        return int(existing[0].consecutive_number) + 1\r\n    else:\r\n        return 1\r\n\r\ndef generate_batch_code(doc):\r\n    \"\"\"Generate batch code\"\"\"\r\n    try:\r\n        plant_code = str(doc.production_plant_name)[0].upper() if doc.production_plant_name else \"X\"\r\n        consecutive = str(doc.consecutive_number).zfill(3)\r\n        lft_str = str(doc.lft or \"0000\").zfill(4)\r\n        rgt_str = str(doc.rgt or \"00000\").zfill(5)\r\n        \r\n        batch_code = f\"{lft_str}{rgt_str}{plant_code}{consecutive}\"\r\n        \r\n        level = doc.custom_batch_level or \"1\"\r\n        if level == \"2\":\r\n            return f\"{batch_code}-S{doc.consecutive_number}\"\r\n        elif level == \"3\":\r\n            return f\"{batch_code}-C{str(doc.consecutive_number).zfill(3)}\"\r\n        elif level == \"4\":\r\n            return f\"{batch_code}-P{doc.consecutive_number}\"\r\n        else:\r\n            return batch_code\r\n            \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error generating batch code: {str(e)}\")\r\n        return doc.name\r\n\r\ndef validate_batch_hierarchy(doc):\r\n    \"\"\"Validate batch hierarchy\"\"\"\r\n    if not doc.custom_batch_level:\r\n        doc.custom_batch_level = \"1\"\r\n    \r\n    level = int(doc.custom_batch_level)\r\n    \r\n    if level > 1 and not doc.parent_batch_amb:\r\n        frappe.throw(_(\"Parent Batch AMB is required for batch level {0}\").format(level))\r\n    \r\n    if doc.parent_batch_amb:\r\n        try:\r\n            parent = frappe.get_doc(\"Batch AMB\", doc.parent_batch_amb)\r\n            parent_level = int(parent.custom_batch_level or \"1\")\r\n            \r\n            if level != parent_level + 1:\r\n                frappe.throw(_(\"Batch level must be one level below parent. Parent level: {0}, Current level: {1}\").format(parent_level, level))\r\n                \r\n        except frappe.DoesNotExistError:\r\n            frappe.throw(_(\"Parent batch {0} does not exist\").format(doc.parent_batch_amb))",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": "add_batch_node",
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.093360",
  "module": "amb_w_tds",
  "name": "Batch AMB Tree API",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "#import frappe\r\n#from frappe import _\r\n\r\n#@frappe.whitelist()\r\ndef add_batch_node(doctype, is_group, work_order_ref, parent=None, is_root=False):\r\n    \"\"\"Custom method to add Batch AMB nodes - replaces standard treeview\"\"\"\r\n    try:\r\n        # Create new document\r\n        doc = frappe.new_doc(doctype)\r\n        doc.is_group = int(is_group)\r\n        doc.work_order_ref = work_order_ref\r\n        \r\n        if parent and parent != \"null\":\r\n            doc.parent_batch_amb = parent\r\n            # Get parent level and set child level\r\n            parent_level = frappe.db.get_value(\"Batch AMB\", parent, \"custom_batch_level\") or \"1\"\r\n            doc.custom_batch_level = str(int(parent_level) + 1)\r\n        else:\r\n            doc.custom_batch_level = \"1\"\r\n        \r\n        # Set flag to indicate we're processing this document\r\n        frappe.flags.batch_amb_processing = True\r\n        \r\n        try:\r\n            doc.insert()\r\n            \r\n            return {\r\n                \"name\": doc.name,\r\n                \"title\": doc.title or doc.name,\r\n                \"is_group\": doc.is_group,\r\n                \"custom_batch_level\": doc.custom_batch_level\r\n            }\r\n        finally:\r\n            frappe.flags.batch_amb_processing = False\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error adding Batch AMB node: {str(e)}\")\r\n        frappe.throw(_(\"Error creating batch: {0}\").format(str(e)))\r\n\r\n#@frappe.whitelist()\r\ndef get_batch_children(parent=None):\r\n    \"\"\"Get children for tree view\"\"\"\r\n    filters = {}\r\n    if parent and parent != \"null\":\r\n        filters[\"parent_batch_amb\"] = parent\r\n    else:\r\n        filters[\"parent_batch_amb\"] = [\"is\", \"not set\"]\r\n    \r\n    children = frappe.get_all(\r\n        \"Batch AMB\",\r\n        filters=filters,\r\n        fields=[\"name\", \"title\", \"is_group\", \"custom_batch_level\", \"custom_generated_batch_name\"],\r\n        order_by=\"lft\"\r\n    )\r\n    \r\n    # Add has_children flag for tree view\r\n    for child in children:\r\n        child_id = child[\"name\"]\r\n        has_children = frappe.db.exists(\"Batch AMB\", {\"parent_batch_amb\": child_id})\r\n        child[\"has_children\"] = bool(has_children)\r\n    \r\n    return children",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "fix_batch_amb_data",
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.105157",
  "module": "amb_w_tds",
  "name": "Fix Batch AMB Data",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "#import frappe\r\n\r\n#@frappe.whitelist()\r\ndef fix_batch_amb_data():\r\n    \"\"\"Fix existing Batch AMB data by converting lft/rgt to strings\"\"\"\r\n    try:\r\n        batches = frappe.get_all(\"Batch AMB\", fields=[\"name\", \"lft\", \"rgt\"])\r\n        \r\n        for batch in batches:\r\n            updates = {}\r\n            \r\n            if batch.lft is None or batch.lft == \"\":\r\n                updates[\"lft\"] = \"0001\"\r\n            elif isinstance(batch.lft, int):\r\n                updates[\"lft\"] = str(batch.lft).zfill(4)\r\n            elif isinstance(batch.lft, str) and batch.lft.isdigit():\r\n                updates[\"lft\"] = batch.lft.zfill(4)\r\n            \r\n            if batch.rgt is None or batch.rgt == \"\":\r\n                updates[\"rgt\"] = \"0002\"\r\n            elif isinstance(batch.rgt, int):\r\n                updates[\"rgt\"] = str(batch.rgt).zfill(5)\r\n            elif isinstance(batch.rgt, str) and batch.rgt.isdigit():\r\n                updates[\"rgt\"] = batch.rgt.zfill(5)\r\n            \r\n            if updates:\r\n                frappe.db.set_value(\"Batch AMB\", batch.name, updates)\r\n        \r\n        frappe.db.commit()\r\n        return f\"Updated {len(batches)} Batch AMB records\"\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error fixing Batch AMB data: {str(e)}\")\r\n        return f\"Error: {str(e)}\"",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "coa_amb_api_tds_parameters",
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.003936",
  "module": "amb_w_tds",
  "name": "coa_amb_load_tds_parameters",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "COA AMB2",
  "script": "#import frappe\r\n#from frappe import _\r\n\r\n#@frappe.whitelist()\r\ndef load_tds_parameters(coa_name, tds_name):\r\n    try:\r\n        # Get the COA document\r\n        coa_doc = frappe.get_doc('COA AMB', coa_name)\r\n        \r\n        # Clear existing child table\r\n        coa_doc.set('coa_quality_test_parameter', [])\r\n        \r\n        # Get the TDS document\r\n        tds_doc = frappe.get_doc('TDS Product Specification', tds_name)\r\n        \r\n        # Check if TDS has parameters\r\n        if not tds_doc.get('item_quality_inspection_parameter'):\r\n            return {\"success\": False, \"message\": \"No parameters found in TDS\"}\r\n        \r\n        # Copy each parameter from TDS to COA\r\n        param_count = 0\r\n        for tds_param in tds_doc.get('item_quality_inspection_parameter'):\r\n            coa_param = coa_doc.append('coa_quality_test_parameter', {})\r\n            \r\n            # Map the fields\r\n            coa_param.parameter = tds_param.parameter or \"Parameter\"\r\n            coa_param.specification = tds_param.specification or \"\"\r\n            coa_param.min_value = tds_param.min_value\r\n            coa_param.max_value = tds_param.max_value\r\n            coa_param.is_numeric = 1\r\n            coa_param.result_status = \"N/A\"\r\n            \r\n            param_count += 1\r\n        \r\n        # Save the document\r\n        coa_doc.save()\r\n        \r\n        return {\r\n            \"success\": True, \r\n            \"message\": \"Loaded \" + str(param_count) + \" parameters from TDS\",\r\n            \"parameter_count\": param_count\r\n        }\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error loading TDS parameters: {str(e)}\")\r\n        return {\"success\": False, \"message\": str(e)}",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": "test_script",
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.980600",
  "module": "amb_w_tds",
  "name": "test_script",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "COA AMB2",
  "script": "#import frappe\r\n#from frappe import _\r\n\r\ndef before_save(doc, method):\r\n    \"\"\"\r\n    Automatically load TDS parameters when linked_tds is set/changed\r\n    \"\"\"\r\n    # Check if linked_tds is set and has changed\r\n    if doc.linked_tds and doc.has_value_changed('linked_tds'):\r\n        # Clear existing parameters\r\n        doc.set('coa_quality_test_parameter', [])\r\n        \r\n        # Load parameters from TDS\r\n        load_tds_parameters(doc, doc.linked_tds)\r\n\r\ndef load_tds_parameters(coa_doc, tds_name):\r\n    \"\"\"\r\n    Load parameters from TDS to COA\r\n    \"\"\"\r\n    try:\r\n        # Get the TDS document\r\n        tds_doc = frappe.get_doc('TDS Product Specification', tds_name)\r\n        \r\n        # Check if TDS has parameters\r\n        if not tds_doc.get('item_quality_inspection_parameter'):\r\n            frappe.msgprint(_(\"No parameters found in TDS: {0}\").format(tds_name), alert=True)\r\n            return\r\n        \r\n        # Copy each parameter from TDS to COA\r\n        param_count = 0\r\n        for tds_param in tds_doc.get('item_quality_inspection_parameter'):\r\n            coa_param = coa_doc.append('coa_quality_test_parameter', {})\r\n            \r\n            # Map the fields\r\n            coa_param.parameter = tds_param.parameter or \"Parameter\"\r\n            coa_param.specification = tds_param.specification or \"\"\r\n            coa_param.min_value = tds_param.min_value\r\n            coa_param.max_value = tds_param.max_value\r\n            coa_param.is_numeric = 1\r\n            coa_param.result_status = \"N/A\"\r\n            \r\n            param_count += 1\r\n        \r\n        frappe.msgprint(_(\"Loaded {0} parameters from TDS7\").format(param_count), alert=True)\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error loading TDS parameters: {str(e)}\")\r\n        frappe.throw(_(\"Error loading parameters from TDS: {0}\").format(str(e)))",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "coa_amb_api",
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.991872",
  "module": "amb_w_tds",
  "name": "coa_amb_api",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "# Server Script as API endpoint\r\n# Server Script Name: coa_amb_api\r\n# Script Type: API (not DocType Event)\r\n#import frappe\r\n#from frappe import _\r\n\r\n#@frappe.whitelist()\r\ndef reload_tds_parameters(coa_name, tds_name):\r\n    \"\"\"\r\n    API endpoint for manual parameter reload\r\n    \"\"\"\r\n    try:\r\n        coa_doc = frappe.get_doc('COA AMB', coa_name)\r\n        \r\n        # Clear existing parameters\r\n        coa_doc.set('coa_quality_test_parameter', [])\r\n        \r\n        # Load from TDS\r\n        tds_doc = frappe.get_doc('TDS Product Specification', tds_name)\r\n        \r\n        if not tds_doc.get('item_quality_inspection_parameter'):\r\n            return {\"success\": False, \"message\": \"No parameters found in TDS\"}\r\n        \r\n        param_count = 0\r\n        for tds_param in tds_doc.get('item_quality_inspection_parameter'):\r\n            coa_param = coa_doc.append('coa_quality_test_parameter', {})\r\n            coa_param.parameter = tds_param.parameter or \"Parameter\"\r\n            coa_param.specification = tds_param.specification or \"\"\r\n            coa_param.min_value = tds_param.min_value\r\n            coa_param.max_value = tds_param.max_value\r\n            coa_param.is_numeric = 1\r\n            coa_param.result_status = \"N/A\"\r\n            param_count += 1\r\n        \r\n        coa_doc.save()\r\n        \r\n        return {\r\n            \"success\": True, \r\n            \"message\": f\"Loaded {param_count} parameters from TDS\",\r\n            \"parameter_count\": param_count\r\n        }\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error in reload_tds_parameters: {str(e)}\")\r\n        return {\"success\": False, \"message\": str(e)}\r\n#@frappe.whitelist()\r\ndef coa_amb_api(coa_name, tds_name):\r\n    return {\"success\": True, \"message\": \"Parameters found in TDS\"}\r\n    try:\r\n        # Get the COA document\r\n        coa_doc = frappe.get_doc('COA AMB', coa_name)\r\n        \r\n        # Clear existing child table\r\n        coa_doc.set('coa_quality_test_parameter', [])\r\n        \r\n        # Get the TDS document\r\n        tds_doc = frappe.get_doc('TDS Product Specification', tds_name)\r\n        \r\n        # Check if TDS has parameters\r\n        if not tds_doc.get('item_quality_inspection_parameter'):\r\n            return {\"success\": False, \"message\": \"No parameters found in TDS\"}\r\n        \r\n        # Copy each parameter from TDS to COA\r\n        param_count = 0\r\n        for tds_param in tds_doc.get('item_quality_inspection_parameter'):\r\n            coa_param = coa_doc.append('coa_quality_test_parameter', {})\r\n            \r\n            # Map the fields\r\n            coa_param.parameter = tds_param.parameter or \"Parameter\"\r\n            coa_param.specification = tds_param.specification or \"\"\r\n            coa_param.min_value = tds_param.min_value\r\n            coa_param.max_value = tds_param.max_value\r\n            coa_param.is_numeric = 1\r\n            coa_param.result_status = \"N/A\"\r\n            \r\n            param_count += 1\r\n        \r\n        # Save the document\r\n        coa_doc.save()\r\n        \r\n        return {\r\n            \"success\": True, \r\n            \"message\": \"Loaded \" + str(param_count) + \" parameters from TDS\",\r\n            \"parameter_count\": param_count\r\n        }\r\n        \r\n    except Exception as e:\r\n        return {\"success\": False, \"message\": str(e)}",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.923461",
  "module": "amb_w_tds",
  "name": "coa_amb_tds_loader",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "COA AMB2",
  "script": "# DocType Event Server Script\r\ndef before_save(doc, method):\r\n    \"\"\"Automatically load TDS parameters when linked_tds is set\"\"\"\r\n    if doc.linked_tds and doc.docstatus == 0:\r\n        load_tds_parameters_event(doc, doc.linked_tds)\r\n\r\ndef load_tds_parameters_event(coa_doc, tds_name):\r\n    \"\"\"Load parameters for DocType event\"\"\"\r\n    try:\r\n        # Get TDS document\r\n        tds_doc = frappe.get_doc('TDS Product Specification', tds_name)\r\n        \r\n        # Check if TDS has parameters\r\n        if not hasattr(tds_doc, 'item_quality_inspection_parameter') or not tds_doc.item_quality_inspection_parameter:\r\n            frappe.msgprint(\"No parameters found in selected TDS\", alert=True)\r\n            return\r\n        \r\n        # Clear existing parameters\r\n        coa_doc.coa_quality_test_parameter = []\r\n        \r\n        # Copy parameters\r\n        param_count = 0\r\n        for tds_param in tds_doc.item_quality_inspection_parameter:\r\n            new_param = {\r\n                'parameter': tds_param.parameter or 'Parameter',\r\n                'specification': tds_param.specification or '',\r\n                'min_value': tds_param.min_value,\r\n                'max_value': tds_param.max_value,\r\n                'is_numeric': 1,\r\n                'result_status': 'Pending'\r\n            }\r\n            coa_doc.append('coa_quality_test_parameter', new_param)\r\n            param_count += 1\r\n        \r\n        frappe.msgprint(f\"Loaded {param_count} parameters from TDS\", alert=True)\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error loading TDS parameters: {str(e)}\")",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.934963",
  "module": "amb_w_tds",
  "name": "coa_amb",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "COA AMB2",
  "script": "# DocType Event Server Script\r\ndef before_save(doc, method):\r\n    \"\"\"Automatically load TDS parameters when linked_tds is set\"\"\"\r\n    if doc.linked_tds and doc.docstatus == 0:\r\n        load_tds_parameters_event(doc, doc.linked_tds)\r\n\r\ndef load_tds_parameters_event(coa_doc, tds_name):\r\n    \"\"\"Load parameters for DocType event\"\"\"\r\n    try:\r\n        # Get TDS document\r\n        tds_doc = frappe.get_doc('TDS Product Specification', tds_name)\r\n        \r\n        # Check if TDS has parameters\r\n        if not hasattr(tds_doc, 'item_quality_inspection_parameter') or not tds_doc.item_quality_inspection_parameter:\r\n            frappe.msgprint(\"No parameters found in selected TDS\", alert=True)\r\n            return\r\n        \r\n        # Clear existing parameters\r\n        coa_doc.coa_quality_test_parameter = []\r\n        \r\n        # Copy parameters\r\n        param_count = 0\r\n        for tds_param in tds_doc.item_quality_inspection_parameter:\r\n            new_param = {\r\n                'parameter': tds_param.parameter or 'Parameter',\r\n                'specification': tds_param.specification or '',\r\n                'min_value': tds_param.min_value,\r\n                'max_value': tds_param.max_value,\r\n                'is_numeric': 1,\r\n                'result_status': 'Pending'\r\n            }\r\n            coa_doc.append('coa_quality_test_parameter', new_param)\r\n            param_count += 1\r\n        \r\n        frappe.msgprint(f\"Loaded {param_count} parameters from TDS\", alert=True)\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error loading TDS parameters: {str(e)}\")",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": "batch_amb_custom_tree_api",
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.969551",
  "module": "amb_w_tds",
  "name": "batch_amb_custom_tree_api_old",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "# Batch AMB Server Script - Nested Set Compatible (Fixed Version)\r\n\r\n#import frappe\r\n#from frappe import _\r\n\r\ndef before_insert(self, method):\r\n    \"\"\"Set up parent relationship before insert\"\"\"\r\n    if self.custom_batch_level and int(self.custom_batch_level) > 1:\r\n        if not self.parent_batch_amb:\r\n            frappe.throw(_(\"Parent Batch AMB is required for level {0}\").format(self.custom_batch_level))\r\n        \r\n        # Ensure parent field is set for nested set to work properly\r\n        if not hasattr(self, 'parent'):\r\n            self.parent = self.parent_batch_amb\r\n\r\n    # Initialize lft and rgt as integers\r\n    self.lft = 0\r\n    self.rgt = 0\r\n\r\ndef before_save(self, method):\r\n    \"\"\"Validate data before saving\"\"\"\r\n    # Validate batch level and parent relationship\r\n    if self.custom_batch_level and int(self.custom_batch_level) > 1:\r\n        if not self.parent_batch_amb:\r\n            frappe.throw(_(\"Parent Batch AMB is required for level {0}\").format(self.custom_batch_level))\r\n    \r\n    # Force lft and rgt to be integers (CRITICAL)\r\n    self.lft = int(self.lft) if self.lft is not None else 0\r\n    self.rgt = int(self.rgt) if self.rgt is not None else 0\r\n\r\ndef validate(self, method):\r\n    \"\"\"Validate the document\"\"\"\r\n    # Ensure title is set\r\n    if not self.title and self.custom_generated_batch_name:\r\n        self.title = self.custom_generated_batch_name\r\n    \r\n    # Set is_group based on level\r\n    if self.custom_batch_level:\r\n        if int(self.custom_batch_level) == 1:\r\n            self.is_group = 1\r\n        else:\r\n            self.is_group = 0\r\n    \r\n    # Force lft and rgt to be integers\r\n    self.lft = int(self.lft) if self.lft is not None else 0\r\n    self.rgt = int(self.rgt) if self.rgt is not None else 0\r\n\r\ndef on_update(self, method):\r\n    \"\"\"Custom nested set update - let the overridden function handle this\"\"\"\r\n    # The overridden update_nsm function will handle this\r\n    pass",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.727753",
  "module": "amb_w_tds",
  "name": "batch_amb_validate_data",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "def var_to_int(v, d=0):\n    try: \n        return int(v)\n    except Exception:\n        return d\n\ndef var_code39_ok(txt):\n    if not txt:\n        return False\n    s = (txt or '').upper()\n    allowed = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-.$/+%* ')\n    for ch in s:\n        if ch not in allowed:\n            return False\n    return True\n\n# Validate parent relationship\nlevel = var_to_int(doc.custom_batch_level, 0)\nif level > 1 and not doc.parent_batch_amb:\n    frappe.throw(f\"Parent Batch AMB is required for level {doc.custom_batch_level}\")\n\n# Coerce numeric fields if possible\nif doc.get('custom_plant_code'):\n    try:\n        doc.custom_plant_code = int(doc.custom_plant_code)\n    except Exception:\n        pass\n\nif  doc.get('custom_sublot_consecutive'):\n    try:\n        doc.custom_sublot_consecutive = int(doc.custom_sublot_consecutive)\n    except Exception:\n        pass\n\n# Level 3: validate container barrels\nrows = doc.get('container_barrels') or []\nif str(doc.custom_batch_level) == '3' and rows:\n    for i, row in enumerate(rows, start=1):\n        serial = (row.get('barrel_serial_number') or '').strip()\n        gross = row.get('gross_weight')\n        tara = row.get('tara_weight')\n        net = row.get('net_weight')\n        pkg = row.get('packaging_type')\n\n        if serial and not gross:\n            frappe.throw(f\"Row {i}: Gross weight is required for barrel {serial}\")\n\n        if gross and not pkg:\n            frappe.throw(f\"Row {i}: Packaging type is required when gross weight is entered\")\n\n        if gross is not None and tara is not None:\n            calc_net = float(gross) - float(tara)\n            if calc_net <= 0:\n                frappe.throw(f\"Row {i}: Net weight cannot be zero or negative for barrel {serial}\")\n            if not net or abs(float(net) - calc_net) > 0.001:\n                row['net_weight'] = calc_net\n\n        if serial and not var_code39_ok(serial):\n            frappe.throw(f\"Row {i}: Invalid CODE-39 barcode format for barrel {serial}\")",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.824175",
  "module": "amb_w_tds",
  "name": "validate_var_code39_ok",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "\ndef var_to_int(v, d=0):\n    try:\n        return int(v)\n    except Exception:\n        return d\n\ndef var_code39_ok(txt):\n    if not txt:\n        return False\n    s = (txt or '').upper()\n    allowed = set('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-.$/+%* ')\n    for ch in s:\n        if ch not in allowed:\n            return False\n    return True\n\n# Validate parent relationship\nlevel = var_to_int(doc.custom_batch_level, 0)\nif level > 1 and not doc.parent_batch_amb:\n    frappe.throw(f\"Parent Batch AMB is required for level {doc.custom_batch_level}\")\n\n# Coerce numeric fields if possible\nif doc.get('custom_plant_code'):\n    try:\n        doc.custom_plant_code = int(doc.custom_plant_code)\n    except Exception:\n        pass\n\nif doc.get('custom_sublot_consecutive'):\n    try:\n        doc.custom_sublot_consecutive = int(doc.custom_sublot_consecutive)\n    except Exception:\n        pass\n\n# Level 3: validate container barrels\nrows = doc.get('container_barrels') or []\nif str(doc.custom_batch_level) == '3' and rows:\n    for i, row in enumerate(rows, start=1):\n        serial = (row.get('barrel_serial_number') or '').strip()\n        gross = row.get('gross_weight')\n        tara = row.get('tara_weight')\n        net = row.get('net_weight')\n        pkg = row.get('packaging_type')\n\n        if serial and not gross:\n            frappe.throw(f\"Row {i}: Gross weight is required for barrel {serial}\")\n\n        if gross and not pkg:\n            frappe.throw(f\"Row {i}: Packaging type is required when gross weight is entered\")\n\n        if gross is not None and tara is not None:\n            calc_net = float(gross) - float(tara)\n            if calc_net <= 0:\n                frappe.throw(f\"Row {i}: Net weight cannot be zero or negative for barrel {serial}\")\n            if not net or abs(float(net) - calc_net) > 0.001:\n                row['net_weight'] = calc_net\n\n        if serial and not var_code39_ok(serial):\n            frappe.throw(f\"Row {i}: Invalid CODE-39 barcode format for barrel {serial}\")\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Validate",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.705578",
  "module": "amb_w_tds",
  "name": "validate_event",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "def var_to_int(v, d=0):\n    try:\n        return int(v)\n    except Exception:\n        return d\n\n# Ensure title\nif not doc.title and doc.custom_generated_batch_name:\n    doc.title = doc.custom_generated_batch_name\n\n# Set is_group by level\nlevel = var_to_int(doc.custom_batch_level, 0)\ndoc.is_group = 1 if level in (1, 2, 3) else 0\n\n# Uniqueness of barrel serials across containers\nrows = doc.get('container_barrels') or []\nserials = [(r.get('barrel_serial_number') or '').strip() for r in rows if r.get('barrel_serial_number')]\nif serials:\n    existing = frappe.db.sql(\"\"\"\n        SELECT cb.barrel_serial_number, ba.name AS container_name\n        FROM `tabContainer Barrels` cb\n        INNER JOIN `tabBatch AMB` ba ON cb.parent = ba.name\n        WHERE cb.barrel_serial_number IN %(serials)s\n          AND ba.name != %(current)s\n    \"\"\", {'serials': serials, 'current': doc.name or 'new'}, as_dict=True)\n    if existing:\n        info = \", \".join([f\"{r['barrel_serial_number']} (in {r['container_name']})\" for r in existing])\n        frappe.throw(f\"Barrel serial numbers already exist in other containers: {info}\")\n",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Submit",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.749629",
  "module": "amb_w_tds",
  "name": "on_update_validate",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "# Remove any function definitions and use direct calculation\r\nif str(doc.custom_batch_level) == '3':\r\n    # Initialize totals\r\n    tg = 0.0\r\n    tt = 0.0\r\n    tn = 0.0\r\n    cnt = 0\r\n    \r\n    # Get the child table rows\r\n    rows = doc.get('container_barrels') or []\r\n    \r\n    # Calculate totals using simple loops\r\n    for row in rows:\r\n        if row.gross_weight:\r\n            tg += flt(row.gross_weight)\r\n        if row.tara_weight:\r\n            tt += flt(row.tara_weight)\r\n        if row.net_weight:\r\n            tn += flt(row.net_weight)\r\n        if row.barrel_serial_number and str(row.barrel_serial_number).strip():\r\n            cnt += 1\r\n    \r\n    # Assign values directly (avoid complex assignments)\r\n    doc.total_gross_weight = tg\r\n    doc.total_tara_weight = tt\r\n    doc.total_net_weight = tn\r\n    doc.barrel_count = cnt",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": "get_running_batch_announcements",
  "cron_format": null,
  "disabled": 1,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.945503",
  "module": "amb_w_tds",
  "name": "get_running_batch_announcements",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": null,
  "script": "import frappe\r\nfrom frappe.utils import getdate\r\n\r\n@frappe.whitelist()\r\ndef get_running_batch_announcements():\r\n    \"\"\"\r\n    Get currently running batches for navbar display\r\n    \"\"\"\r\n    try:\r\n        # Get running batches (Level 1 main batches only)\r\n        running_batches = frappe.get_all(\r\n            'Batch AMB',\r\n            filters={\r\n                'batch_status': 'Running Now',\r\n                'custom_batch_level': '1',\r\n                'docstatus': ['!=', 2]\r\n            },\r\n            fields=[\r\n                'name', 'custom_generated_batch_name', 'work_order_ref',\r\n                'manufacturing_date', 'production_workstation', 'batch_status',\r\n                'sales_order_related', 'creation'\r\n            ],\r\n            order_by='creation desc',\r\n            limit=3\r\n        )\r\n        \r\n        announcements = []\r\n        \r\n        for batch in running_batches:\r\n            try:\r\n                # Get related sub-lots (Level 2)\r\n                sub_lots = frappe.get_all(\r\n                    'Batch AMB',\r\n                    filters={\r\n                        'parent_batch_amb': batch.name,\r\n                        'custom_batch_level': '2'\r\n                    },\r\n                    fields=['custom_generated_batch_name'],\r\n                    limit=1\r\n                )\r\n                \r\n                # Get sales order info\r\n                sales_order = batch.sales_order_related or 'N/A'\r\n                if batch.work_order_ref and sales_order == 'N/A':\r\n                    try:\r\n                        work_order = frappe.get_doc('Work Order', batch.work_order_ref)\r\n                        sales_order = work_order.sales_order if hasattr(work_order, 'sales_order') and work_order.sales_order else 'N/A'\r\n                    except:\r\n                        sales_order = 'N/A'\r\n                \r\n                # Format manufacturing date\r\n                manufacturing_date = 'N/A'\r\n                if batch.manufacturing_date:\r\n                    try:\r\n                        date_obj = getdate(batch.manufacturing_date)\r\n                        manufacturing_date = date_obj.strftime('%Y-%m-%d')\r\n                    except:\r\n                        manufacturing_date = str(batch.manufacturing_date)\r\n                \r\n                # Create announcement text\r\n                announcement_text = f\"\"\"🏭 LOTE EN PRODUCCION: {batch.custom_generated_batch_name or batch.name}\r\n📋 ORDEN DE TRABAJO: {batch.work_order_ref or 'N/A'}\r\n📦 NUMERO DE SUB-LOTE: {sub_lots[0].custom_generated_batch_name if sub_lots else 'N/A'}\r\n🛒 PEDIDO DE VENTA: {sales_order}\r\n⚡ STATUS: {batch.batch_status}\r\n📍 ESTACIÓN: {batch.production_workstation or 'N/A'}\r\n📅 FECHA: {manufacturing_date}\"\"\"\r\n                \r\n                announcements.append({\r\n                    'title': f'Batch {batch.custom_generated_batch_name or batch.name}',\r\n                    'content': announcement_text,\r\n                    'batch_name': batch.name,\r\n                    'priority': 'high',\r\n                    'timestamp': frappe.utils.now()\r\n                })\r\n                \r\n            except Exception as e:\r\n                frappe.log_error(f\"Error processing batch {batch.name}: {str(e)}\", \"Batch Announcement Error\")\r\n                continue\r\n        \r\n        return {\r\n            'success': True,\r\n            'announcements': announcements,\r\n            'count': len(announcements),\r\n            'timestamp': frappe.utils.now()\r\n        }\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error in get_running_batch_announcements: {str(e)}\", \"Batch Announcement Error\")\r\n        return {\r\n            'success': False,\r\n            'error': str(e),\r\n            'announcements': [],\r\n            'count': 0\r\n        }",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "coa_amb_api_tds_parameters",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.912684",
  "module": "amb_w_tds",
  "name": "coa_amb_load_tds_parameters_1",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "COA AMB",
  "script": "#import frappe\r\n#from frappe import _\r\n\r\n#@frappe.whitelist()\r\ndef load_tds_parameters(coa_name, tds_name):\r\n    try:\r\n        # Get the COA document\r\n        coa_doc = frappe.get_doc('COA AMB', coa_name)\r\n        \r\n        # Clear existing child table\r\n        coa_doc.set('coa_quality_test_parameter', [])\r\n        \r\n        # Get the TDS document\r\n        tds_doc = frappe.get_doc('TDS Product Specification', tds_name)\r\n        \r\n        # Check if TDS has parameters\r\n        if not tds_doc.get('item_quality_inspection_parameter'):\r\n            return {\"success\": False, \"message\": \"No parameters found in TDS\"}\r\n        \r\n        # Copy each parameter from TDS to COA\r\n        param_count = 0\r\n        for tds_param in tds_doc.get('item_quality_inspection_parameter'):\r\n            coa_param = coa_doc.append('coa_quality_test_parameter', {})\r\n            \r\n            # Map the fields\r\n            coa_param.parameter = tds_param.parameter or \"Parameter\"\r\n            coa_param.specification = tds_param.specification or \"\"\r\n            coa_param.min_value = tds_param.min_value\r\n            coa_param.max_value = tds_param.max_value\r\n            coa_param.is_numeric = 1\r\n            coa_param.result_status = \"N/A\"\r\n            \r\n            param_count += 1\r\n        \r\n        # Save the document\r\n        coa_doc.save()\r\n        \r\n        return {\r\n            \"success\": True, \r\n            \"message\": \"Loaded \" + str(param_count) + \" parameters from TDS\",\r\n            \"parameter_count\": param_count\r\n        }\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error loading TDS parameters: {str(e)}\")\r\n        return {\"success\": False, \"message\": str(e)}",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.901321",
  "module": "amb_w_tds",
  "name": "coa_amb_tds_loader_1",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "COA AMB",
  "script": "# DocType Event Server Script\r\ndef before_save(doc, method):\r\n    \"\"\"Automatically load TDS parameters when linked_tds is set\"\"\"\r\n    if doc.linked_tds and doc.docstatus == 0:\r\n        load_tds_parameters_event(doc, doc.linked_tds)\r\n\r\ndef load_tds_parameters_event(coa_doc, tds_name):\r\n    \"\"\"Load parameters for DocType event\"\"\"\r\n    try:\r\n        # Get TDS document\r\n        tds_doc = frappe.get_doc('TDS Product Specification', tds_name)\r\n        \r\n        # Check if TDS has parameters\r\n        if not hasattr(tds_doc, 'item_quality_inspection_parameter') or not tds_doc.item_quality_inspection_parameter:\r\n            frappe.msgprint(\"No parameters found in selected TDS\", alert=True)\r\n            return\r\n        \r\n        # Clear existing parameters\r\n        coa_doc.coa_quality_test_parameter = []\r\n        \r\n        # Copy parameters\r\n        param_count = 0\r\n        for tds_param in tds_doc.item_quality_inspection_parameter:\r\n            new_param = {\r\n                'parameter': tds_param.parameter or 'Parameter',\r\n                'specification': tds_param.specification or '',\r\n                'min_value': tds_param.min_value,\r\n                'max_value': tds_param.max_value,\r\n                'is_numeric': 1,\r\n                'result_status': 'Pending'\r\n            }\r\n            coa_doc.append('coa_quality_test_parameter', new_param)\r\n            param_count += 1\r\n        \r\n        frappe.msgprint(f\"Loaded {param_count} parameters from TDS\", alert=True)\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error loading TDS parameters: {str(e)}\")",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.889999",
  "module": "amb_w_tds",
  "name": "coa_amb_1",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "COA AMB",
  "script": "# DocType Event Server Script\r\ndef before_save(doc, method):\r\n    \"\"\"Automatically load TDS parameters when linked_tds is set\"\"\"\r\n    if doc.linked_tds and doc.docstatus == 0:\r\n        load_tds_parameters_event(doc, doc.linked_tds)\r\n\r\ndef load_tds_parameters_event(coa_doc, tds_name):\r\n    \"\"\"Load parameters for DocType event\"\"\"\r\n    try:\r\n        # Get TDS document\r\n        tds_doc = frappe.get_doc('TDS Product Specification', tds_name)\r\n        \r\n        # Check if TDS has parameters\r\n        if not hasattr(tds_doc, 'item_quality_inspection_parameter') or not tds_doc.item_quality_inspection_parameter:\r\n            frappe.msgprint(\"No parameters found in selected TDS\", alert=True)\r\n            return\r\n        \r\n        # Clear existing parameters\r\n        coa_doc.coa_quality_test_parameter = []\r\n        \r\n        # Copy parameters\r\n        param_count = 0\r\n        for tds_param in tds_doc.item_quality_inspection_parameter:\r\n            new_param = {\r\n                'parameter': tds_param.parameter or 'Parameter',\r\n                'specification': tds_param.specification or '',\r\n                'min_value': tds_param.min_value,\r\n                'max_value': tds_param.max_value,\r\n                'is_numeric': 1,\r\n                'result_status': 'Pending'\r\n            }\r\n            coa_doc.append('coa_quality_test_parameter', new_param)\r\n            param_count += 1\r\n        \r\n        frappe.msgprint(f\"Loaded {param_count} parameters from TDS\", alert=True)\r\n        \r\n    except Exception as e:\r\n        frappe.log_error(f\"Error loading TDS parameters: {str(e)}\")",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": "calculate_escalated_prices",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.860162",
  "module": "amb_w_tds",
  "name": "Quotation Item Escalated Server Script",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Quotation",
  "script": "# Server Script for Quotation Item Escalated calculations\r\n# Enabled: Yes\r\n# Reference Doctype: Quotation Item Escalated\r\n# Script Type: API\r\n\r\ndef calculate_escalated_prices(doc, method):\r\n    # Calculate freight cost based on quantity\r\n    freight_cost = calculate_freight_cost(doc.qty)\r\n    doc.freight_cost = freight_cost\r\n    \r\n    # Apply quantity-based escalation\r\n    escalated_rate = apply_quantity_escalation(doc.price_list_rate, doc.qty)\r\n    doc.escalated_rate = escalated_rate\r\n    \r\n    # Calculate final rate\r\n    doc.rate = flt(escalated_rate) + flt(freight_cost)\r\n    \r\n    # Calculate amount\r\n    if doc.qty and doc.rate:\r\n        doc.amount = flt(doc.qty) * flt(doc.rate)\r\n        \r\n        # Calculate net amount if discount exists\r\n        if doc.discount_percentage:\r\n            doc.discount_amount = flt(doc.amount) * flt(doc.discount_percentage) / 100\r\n            doc.net_amount = flt(doc.amount) - flt(doc.discount_amount)\r\n            \r\n            if doc.qty:\r\n                doc.net_rate = flt(doc.net_amount) / flt(doc.qty)\r\n\r\ndef calculate_freight_cost(quantity):\r\n    quantity = flt(quantity)\r\n    if quantity <= 1:\r\n        return 58.30\r\n    elif quantity <= 5:\r\n        return 19.87\r\n    elif quantity <= 10:\r\n        return 16.06\r\n    elif quantity <= 20:\r\n        return 14.17\r\n    else:\r\n        return 13.91\r\n\r\ndef apply_quantity_escalation(base_price, quantity):\r\n    base_price = flt(base_price)\r\n    quantity = flt(quantity)\r\n    \r\n    if quantity >= 100:\r\n        return base_price * 0.9  # 10% discount\r\n    elif quantity >= 50:\r\n        return base_price * 0.95  # 5% discount\r\n    else:\r\n        return base_price\r\n\r\n# Hook this function to validate event\r\ncalculate_escalated_prices",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": "QuotationItemEscalated",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.847696",
  "module": "amb_w_tds",
  "name": "QuotationItemEscalated",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Quotation Item Escalated",
  "script": "class QuotationItemEscalated(Document):\r\n    def validate(self):\r\n        self.set_quantity_limits()\r\n        self.calculate_prices()\r\n    \r\n    def set_quantity_limits(self):\r\n        \"\"\"Set min and max quantity based on selected range\"\"\"\r\n        if self.quantity_range:\r\n            ranges = {\r\n                '1-5 kg': (1, 5),\r\n                '6-10 kg': (6, 10),\r\n                '11-25 kg': (11, 25),\r\n                '26-200 kg': (26, 200)\r\n            }\r\n            \r\n            if self.quantity_range in ranges:\r\n                self.min_quantity, self.max_quantity = ranges[self.quantity_range]\r\n    \r\n    def calculate_prices(self):\r\n        \"\"\"Calculate all prices based on quantity range\"\"\"\r\n        if self.ex_works_price and self.freight_cost and self.min_quantity:\r\n            # Calculate delivered price\r\n            self.delivered_price = flt(self.ex_works_price) + flt(self.freight_cost)\r\n            \r\n            # Calculate price per kg\r\n            self.price_per_kg = self.delivered_price\r\n            \r\n            # Calculate total price range\r\n            if self.min_quantity == self.max_quantity:\r\n                self.total_price = self.delivered_price * self.min_quantity\r\n            else:\r\n                # Store the maximum total for the range\r\n                self.total_price = self.delivered_price * self.max_quantity\r\n    \r\n    def calculate_freight_based_on_type(self):\r\n        \"\"\"Calculate freight cost based on freight type and quantity range\"\"\"\r\n        if self.quantity_range and self.freight_type:\r\n            freight_matrix = {\r\n                '1-5 kg': {\r\n                    'Air Freight': 58.30,\r\n                    'Sea Freight': 45.00,\r\n                    'Ground': 35.00,\r\n                    'Door to Door': 60.00\r\n                },\r\n                '6-10 kg': {\r\n                    'Air Freight': 19.87,\r\n                    'Sea Freight': 15.00,\r\n                    'Ground': 12.00,\r\n                    'Door to Door': 22.00\r\n                },\r\n                '11-25 kg': {\r\n                    'Air Freight': 16.06,\r\n                    'Sea Freight': 12.00,\r\n                    'Ground': 9.00,\r\n                    'Door to Door': 18.00\r\n                },\r\n                '26-200 kg': {\r\n                    'Air Freight': 13.91,\r\n                    'Sea Freight': 10.00,\r\n                    'Ground': 7.00,\r\n                    'Door to Door': 15.00\r\n                }\r\n            }\r\n            \r\n            if (self.quantity_range in freight_matrix and \r\n                self.freight_type in freight_matrix[self.quantity_range]):\r\n                self.freight_cost = freight_matrix[self.quantity_range][self.freight_type]",
  "script_type": "API"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.771370",
  "module": "amb_w_tds",
  "name": "Complex Workflow Management",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "#import frappe\r\n#from frappe import _\r\n#from frappe.utils import getdate, nowdate\r\n#from datetime import datetime\r\n\r\ndef validate_batch_transition(doc, method):\r\n    \"\"\"\r\n    Validate batch transitions between plants and quality states\r\n    \"\"\"\r\n    if doc.is_new():\r\n        # New batch - set initial values\r\n        doc.original_item_code = doc.item_to_manufacture\r\n        doc.current_item_code = doc.item_to_manufacture\r\n        doc.quality_status = \"Pending\"\r\n        return\r\n    \r\n    # Get previous values from doc_before_save\r\n    doc_before_save = doc.get_doc_before_save()\r\n    if not doc_before_save:\r\n        return\r\n    \r\n    # Check if plant is changing\r\n    if doc_before_save.get('current_plant') != doc.current_plant:\r\n        validate_plant_transition(doc, doc_before_save.get('current_plant'))\r\n    \r\n    # Check if item code is changing\r\n    if doc_before_save.get('current_item_code') != doc.current_item_code:\r\n        validate_item_code_change(doc, doc_before_save.get('current_item_code'))\r\n\r\ndef validate_plant_transition(doc, previous_plant):\r\n    \"\"\"\r\n    Validate transitions between specific plants\r\n    \"\"\"\r\n    current_plant = doc.current_plant\r\n    \r\n    # Define allowed transitions\r\n    allowed_transitions = {\r\n        '3': ['2', '4'],  # Juice Plant can go to Dry Plant or Laboratory\r\n        '2': ['1', '4'],  # Dry Plant can go to Mix Plant or Laboratory\r\n        '4': ['1', '5'],  # Laboratory can go to Mix Plant or Formulated\r\n        '1': ['4'],       # Mix Plant goes back to Laboratory for testing\r\n        '5': ['4']        # Formulated goes to Laboratory for testing\r\n    }\r\n    \r\n    if previous_plant and current_plant not in allowed_transitions.get(previous_plant, []):\r\n        frappe.throw(_(\"Cannot move batch from Plant {0} to Plant {1}\").format(previous_plant, current_plant))\r\n\r\ndef validate_item_code_change(doc, previous_item_code):\r\n    \"\"\"\r\n    Validate item code changes based on quality status and plant\r\n    \"\"\"\r\n    if doc.quality_status != \"Passed\" and doc.current_plant != \"4\":\r\n        frappe.throw(_(\"Item code can only be changed after quality approval from Laboratory\"))\r\n    \r\n    # Add specific validation rules for item code transitions\r\n    # Example: 0301 can become 0334 only after mixing\r\n    allowed_transitions = {\r\n        '0301': ['0334', '0302', '0303', '0304'],\r\n        '0302': ['0334', '0303', '0304'],\r\n        '0303': ['0334', '0304'],\r\n        '0304': ['0334']\r\n    }\r\n    \r\n    current_code = doc.current_item_code\r\n    \r\n    if previous_item_code and current_code not in allowed_transitions.get(previous_item_code, []):\r\n        frappe.throw(_(\"Cannot change item code from {0} to {1}\").format(previous_item_code, current_code))\r\n\r\ndef after_save_workflow(doc, method):\r\n    \"\"\"\r\n    Handle post-save workflow actions\r\n    \"\"\"\r\n    # Add to processing history\r\n    add_processing_history(doc)\r\n    \r\n    # Auto-create next work order if needed\r\n    if should_create_next_wo(doc):\r\n        create_next_work_order(doc)\r\n    \r\n    # Update COA relationship if quality passed\r\n    if doc.quality_status == \"Passed\" and doc.coa_reference:\r\n        link_coa_to_batch(doc)\r\n\r\ndef add_processing_history(doc):\r\n    \"\"\"\r\n    Record processing history for audit trail\r\n    \"\"\"\r\n    # Get previous values from doc_before_save\r\n    doc_before_save = doc.get_doc_before_save()\r\n    \r\n    history = {\r\n        \"date\": nowdate(),\r\n        \"plant\": doc.current_plant,\r\n        \"item_code\": doc.current_item_code,\r\n        \"quality_status\": doc.quality_status,\r\n        \"action\": \"Batch updated\"\r\n    }\r\n    \r\n    # Add previous values if available\r\n    if doc_before_save:\r\n        if doc_before_save.get('current_plant') != doc.current_plant:\r\n            history[\"previous_value\"] = f\"Plant: {doc_before_save.get('current_plant')}\"\r\n            history[\"new_value\"] = f\"Plant: {doc.current_plant}\"\r\n        \r\n        if doc_before_save.get('current_item_code') != doc.current_item_code:\r\n            history[\"previous_value\"] = f\"Item: {doc_before_save.get('current_item_code')}\"\r\n            history[\"new_value\"] = f\"Item: {doc.current_item_code}\"\r\n    \r\n    # Initialize history table if empty\r\n    if not doc.processing_history:\r\n        doc.processing_history = []\r\n    \r\n    # Add new history entry\r\n    doc.append(\"processing_history\", history)\r\n\r\ndef should_create_next_wo(doc):\r\n    \"\"\"\r\n    Determine if next work order should be created\r\n    \"\"\"\r\n    conditions = [\r\n        doc.quality_status == \"Passed\",\r\n        doc.current_plant in [\"2\", \"4\"],  # After drying or quality check\r\n        not doc.next_processing_wo  # No next WO already created\r\n    ]\r\n    \r\n    return all(conditions)\r\n\r\ndef create_next_work_order(doc):\r\n    \"\"\"\r\n    Automatically create next work order based on current state\r\n    \"\"\"\r\n    target_plant = get_next_plant(doc.current_plant, doc.current_item_code)\r\n    \r\n    wo = frappe.new_doc(\"Work Order\")\r\n    wo.production_item = doc.current_item_code\r\n    wo.company = get_company_for_plant(target_plant)\r\n    wo.planned_start_date = frappe.utils.add_days(nowdate(), 1)\r\n    wo.custom_plant_code = target_plant\r\n    wo.qty = calculate_next_quantity(doc)\r\n    \r\n    # Set custom fields based on your requirements\r\n    wo.insert()\r\n    \r\n    doc.next_processing_wo = wo.name\r\n    doc.target_plant = target_plant\r\n    \r\n    frappe.msgprint(_(\"Created next work order: {0}\").format(wo.name))\r\n\r\ndef get_next_plant(current_plant, item_code):\r\n    \"\"\"\r\n    Determine the next plant based on current state and item code\r\n    \"\"\"\r\n    plant_rules = {\r\n        '3': '2',  # Juice → Dry\r\n        '2': '4',  # Dry → Laboratory\r\n        '4': get_mixing_plant_for_item(item_code),  # Lab → Mix/Formulated\r\n        '1': '4',  # Mix → Laboratory\r\n        '5': '4'   # Formulated → Laboratory\r\n    }\r\n    \r\n    return plant_rules.get(current_plant, '4')  # Default to laboratory\r\n\r\ndef get_mixing_plant_for_item(item_code):\r\n    \"\"\"\r\n    Determine if item goes to Mix Plant (1) or Formulated Plant (5)\r\n    \"\"\"\r\n    # Your business rules here - example:\r\n    if item_code.startswith('03'):\r\n        return '1'  # Mix Plant\r\n    elif item_code.startswith('05'):\r\n        return '5'  # Formulated Plant\r\n    else:\r\n        return '1'  # Default to Mix Plant\r\n\r\ndef get_company_for_plant(plant_code):\r\n    \"\"\"\r\n    Map plant codes to companies\r\n    \"\"\"\r\n    plant_company_map = {\r\n        '1': 'AMB-Wellness',\r\n        '2': 'Dry Plant Company',  # Adjust as needed\r\n        '3': 'Juice',\r\n        '4': 'AMB-Wellness',  # Laboratory typically same as main company\r\n        '5': 'AMB-Wellness'   # Formulated typically same as main company\r\n    }\r\n    return plant_company_map.get(plant_code, 'AMB-Wellness')\r\n\r\ndef calculate_next_quantity(doc):\r\n    \"\"\"\r\n    Calculate quantity for next work order with potential losses\r\n    \"\"\"\r\n    # Get current quantity from somewhere - you might need to track this\r\n    current_qty = 1000  # Example - replace with actual logic\r\n    \r\n    # Apply processing losses based on plant\r\n    loss_factors = {\r\n        '2': 0.9,  # 10% loss in drying\r\n        '1': 0.95, # 5% loss in mixing\r\n        '5': 0.98  # 2% loss in formulation\r\n    }\r\n    \r\n    return current_qty * loss_factors.get(doc.target_plant, 1)\r\n\r\ndef link_coa_to_batch(doc):\r\n    \"\"\"\r\n    Link COA to batch and update related fields\r\n    \"\"\"\r\n    coa = frappe.get_doc(\"COA AMB\", doc.coa_reference)\r\n    \r\n    # Update batch with COA results\r\n    doc.db_set({\r\n        \"quality_status\": \"Passed\",\r\n        \"current_item_code\": coa.final_item_code or doc.current_item_code\r\n    })\r\n    \r\n    # Also update the related work order if exists\r\n    if doc.work_order_ref:\r\n        frappe.db.set_value(\"Work Order\", doc.work_order_ref, {\r\n            \"quality_status\": \"Completed\",\r\n            \"custom_final_item_code\": coa.final_item_code\r\n        })",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Save",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.787140",
  "module": "amb_w_tds",
  "name": "History Tracking",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "#import frappe\r\n#from frappe import _\r\n#from frappe.utils import now, get_fullname\r\n\r\ndef validate_batch_transition(doc, method):\r\n    \"\"\"\r\n    Validate batch transitions between plants and quality states\r\n    \"\"\"\r\n    if doc.is_new():\r\n        # New batch - set initial values and add first history entry\r\n        doc.original_item_code = doc.item_to_manufacture\r\n        doc.current_item_code = doc.item_to_manufacture\r\n        doc.quality_status = \"Pending\"\r\n        add_processing_history(doc, \"System\", \"Batch Created\", \r\n                              f\"Initial creation with item {doc.item_to_manufacture}\")\r\n        return\r\n    \r\n    # Get the document before save for comparison\r\n    doc_before_save = doc.get_doc_before_save()\r\n    if not doc_before_save:\r\n        return\r\n    \r\n    # Track changes for history\r\n    changes = {}\r\n    \r\n    # Check if plant is changing\r\n    if doc_before_save.get('current_plant') != doc.current_plant:\r\n        validate_plant_transition(doc, doc_before_save.get('current_plant'))\r\n        changes['plant'] = (doc_before_save.get('current_plant'), doc.current_plant)\r\n    \r\n    # Check if item code is changing\r\n    if doc_before_save.get('current_item_code') != doc.current_item_code:\r\n        validate_item_code_change(doc, doc_before_save.get('current_item_code'))\r\n        changes['item_code'] = (doc_before_save.get('current_item_code'), doc.current_item_code)\r\n    \r\n    # Check if quality status is changing\r\n    if doc_before_save.get('quality_status') != doc.quality_status:\r\n        changes['quality_status'] = (doc_before_save.get('quality_status'), doc.quality_status)\r\n    \r\n    # Add history entry for changes\r\n    if changes:\r\n        action = \"Batch Updated\"\r\n        comments = \"Changes: \" + \", \".join([f\"{k}: {v[0]}→{v[1]}\" for k, v in changes.items()])\r\n        add_processing_history(doc, get_fullname(frappe.session.user), action, comments)\r\n\r\ndef validate_plant_transition(doc, previous_plant):\r\n    \"\"\"\r\n    Validate transitions between specific plants\r\n    \"\"\"\r\n    current_plant = doc.current_plant\r\n    \r\n    # Define allowed transitions\r\n    allowed_transitions = {\r\n        '3': ['2', '4'],  # Juice Plant can go to Dry Plant or Laboratory\r\n        '2': ['1', '4'],  # Dry Plant can go to Mix Plant or Laboratory\r\n        '4': ['1', '5'],  # Laboratory can go to Mix Plant or Formulated\r\n        '1': ['4'],       # Mix Plant goes back to Laboratory for testing\r\n        '5': ['4']        # Formulated goes to Laboratory for testing\r\n    }\r\n    \r\n    if previous_plant and current_plant not in allowed_transitions.get(previous_plant, []):\r\n        frappe.throw(_(\"Cannot move batch from Plant {0} to Plant {1}\").format(previous_plant, current_plant))\r\n\r\ndef validate_item_code_change(doc, previous_item_code):\r\n    \"\"\"\r\n    Validate item code changes based on quality status and plant\r\n    \"\"\"\r\n    if doc.quality_status != \"Passed\" and doc.current_plant != \"4\":\r\n        frappe.throw(_(\"Item code can only be changed after quality approval from Laboratory\"))\r\n    \r\n    # Add specific validation rules for item code transitions\r\n    # Example: 0301 can become 0334 only after mixing\r\n    allowed_transitions = {\r\n        '0301': ['0334', '0302', '0303', '0304'],\r\n        '0302': ['0334', '0303', '0304'],\r\n        '0303': ['0334', '0304'],\r\n        '0304': ['0334']\r\n    }\r\n    \r\n    current_code = doc.current_item_code\r\n    \r\n    if previous_item_code and current_code not in allowed_transitions.get(previous_item_code, []):\r\n        frappe.throw(_(\"Cannot change item code from {0} to {1}\").format(previous_item_code, current_code))\r\n\r\ndef add_processing_history(doc, changed_by, action, comments=None, system_generated=False):\r\n    \"\"\"\r\n    Add an entry to the processing history table\r\n    \"\"\"\r\n    history_entry = {\r\n        \"date\": now(),\r\n        \"plant\": doc.current_plant,\r\n        \"item_code\": doc.current_item_code,\r\n        \"quality_status\": doc.quality_status,\r\n        \"processing_action\": action,\r\n        \"changed_by\": changed_by,\r\n        \"comments\": comments,\r\n        \"system_generated\": 1 if system_generated else 0\r\n    }\r\n    \r\n    # Add COA reference if available\r\n    if doc.coa_reference:\r\n        history_entry[\"coa_reference\"] = doc.coa_reference\r\n    \r\n    # Initialize history table if empty\r\n    if not doc.processing_history:\r\n        doc.processing_history = []\r\n    \r\n    # Add new history entry\r\n    doc.append(\"processing_history\", history_entry)\r\n\r\ndef after_save_workflow(doc, method):\r\n    \"\"\"\r\n    Handle post-save workflow actions with history tracking\r\n    \"\"\"\r\n    # Auto-create next work order if needed\r\n    if should_create_next_wo(doc):\r\n        wo = create_next_work_order(doc)\r\n        if wo:\r\n            # Add history entry for work order creation\r\n            add_processing_history(doc, \"System\", \"Work Order Created\", \r\n                                  f\"Created work order {wo.name} for next processing\", \r\n                                  system_generated=True)\r\n    \r\n    # Update COA relationship if quality passed\r\n    if doc.quality_status == \"Passed\" and doc.coa_reference:\r\n        link_coa_to_batch(doc)\r\n        add_processing_history(doc, \"System\", \"COA Linked\", \r\n                              f\"Linked COA {doc.coa_reference} to batch\", \r\n                              system_generated=True)\r\n\r\ndef on_quality_status_change(doc, method):\r\n    \"\"\"\r\n    Handle quality status changes with detailed history\r\n    \"\"\"\r\n    doc_before_save = doc.get_doc_before_save()\r\n    if not doc_before_save:\r\n        return\r\n        \r\n    if doc_before_save.get('quality_status') != doc.quality_status:\r\n        old_status = doc_before_save.get('quality_status')\r\n        new_status = doc.quality_status\r\n        \r\n        action = \"Quality Status Changed\"\r\n        comments = f\"Quality changed from {old_status} to {new_status}\"\r\n        \r\n        if doc.coa_reference:\r\n            comments += f\" based on COA {doc.coa_reference}\"\r\n        \r\n        add_processing_history(doc, get_fullname(frappe.session.user), action, comments)\r\n\r\ndef on_plant_transfer(doc, method):\r\n    \"\"\"\r\n    Handle plant transfers with detailed history\r\n    \"\"\"\r\n    doc_before_save = doc.get_doc_before_save()\r\n    if not doc_before_save:\r\n        return\r\n        \r\n    if doc_before_save.get('current_plant') != doc.current_plant:\r\n        old_plant = doc_before_save.get('current_plant')\r\n        new_plant = doc.current_plant\r\n        \r\n        plant_names = {\r\n            \"1\": \"Mix Plant\",\r\n            \"2\": \"Dry Plant\", \r\n            \"3\": \"Juice Plant\",\r\n            \"4\": \"Laboratory\",\r\n            \"5\": \"Formulated Plant\"\r\n        }\r\n        \r\n        action = \"Plant Transfer\"\r\n        comments = f\"Transferred from {plant_names.get(old_plant, old_plant)} to {plant_names.get(new_plant, new_plant)}\"\r\n        \r\n        add_processing_history(doc, get_fullname(frappe.session.user), action, comments)\r\n\r\ndef should_create_next_wo(doc):\r\n    \"\"\"\r\n    Determine if next work order should be created\r\n    \"\"\"\r\n    conditions = [\r\n        doc.quality_status == \"Passed\",\r\n        doc.current_plant in [\"2\", \"4\"],  # After drying or quality check\r\n        not doc.next_processing_wo  # No next WO already created\r\n    ]\r\n    \r\n    return all(conditions)\r\n\r\ndef create_next_work_order(doc):\r\n    \"\"\"\r\n    Automatically create next work order based on current state\r\n    \"\"\"\r\n    target_plant = get_next_plant(doc.current_plant, doc.current_item_code)\r\n    \r\n    wo = frappe.new_doc(\"Work Order\")\r\n    wo.production_item = doc.current_item_code\r\n    wo.company = get_company_for_plant(target_plant)\r\n    wo.planned_start_date = frappe.utils.add_days(now(), 1)\r\n    wo.custom_plant_code = target_plant\r\n    wo.qty = calculate_next_quantity(doc)\r\n    \r\n    # Set custom fields based on your requirements\r\n    wo.insert()\r\n    \r\n    doc.next_processing_wo = wo.name\r\n    doc.target_plant = target_plant\r\n    \r\n    frappe.msgprint(_(\"Created next work order: {0}\").format(wo.name))\r\n    return wo\r\n\r\ndef get_next_plant(current_plant, item_code):\r\n    \"\"\"\r\n    Determine the next plant based on current state and item code\r\n    \"\"\"\r\n    plant_rules = {\r\n        '3': '2',  # Juice → Dry\r\n        '2': '4',  # Dry → Laboratory\r\n        '4': get_mixing_plant_for_item(item_code),  # Lab → Mix/Formulated\r\n        '1': '4',  # Mix → Laboratory\r\n        '5': '4'   # Formulated → Laboratory\r\n    }\r\n    \r\n    return plant_rules.get(current_plant, '4')  # Default to laboratory\r\n\r\ndef get_mixing_plant_for_item(item_code):\r\n    \"\"\"\r\n    Determine if item goes to Mix Plant (1) or Formulated Plant (5)\r\n    \"\"\"\r\n    # Your business rules here - example:\r\n    if item_code.startswith('03'):\r\n        return '1'  # Mix Plant\r\n    elif item_code.startswith('05'):\r\n        return '5'  # Formulated Plant\r\n    else:\r\n        return '1'  # Default to Mix Plant\r\n\r\ndef get_company_for_plant(plant_code):\r\n    \"\"\"\r\n    Map plant codes to companies\r\n    \"\"\"\r\n    plant_company_map = {\r\n        '1': 'AMB-Wellness',\r\n        '2': 'Dry Plant Company',  # Adjust as needed\r\n        '3': 'Juice',\r\n        '4': 'AMB-Wellness',  # Laboratory typically same as main company\r\n        '5': 'AMB-Wellness'   # Formulated typically same as main company\r\n    }\r\n    return plant_company_map.get(plant_code, 'AMB-Wellness')\r\n\r\ndef calculate_next_quantity(doc):\r\n    \"\"\"\r\n    Calculate quantity for next work order with potential losses\r\n    \"\"\"\r\n    # Get current quantity from somewhere - you might need to track this\r\n    current_qty = 1000  # Example - replace with actual logic\r\n    \r\n    # Apply processing losses based on plant\r\n    loss_factors = {\r\n        '2': 0.9,  # 10% loss in drying\r\n        '1': 0.95, # 5% loss in mixing\r\n        '5': 0.98  # 2% loss in formulation\r\n    }\r\n    \r\n    return current_qty * loss_factors.get(doc.target_plant, 1)\r\n\r\ndef link_coa_to_batch(doc):\r\n    \"\"\"\r\n    Link COA to batch and update related fields\r\n    \"\"\"\r\n    coa = frappe.get_doc(\"COA AMB\", doc.coa_reference)\r\n    \r\n    # Update batch with COA results\r\n    doc.db_set({\r\n        \"quality_status\": \"Passed\",\r\n        \"current_item_code\": coa.final_item_code or doc.current_item_code\r\n    })\r\n    \r\n    # Also update the related work order if exists\r\n    if doc.work_order_ref:\r\n        frappe.db.set_value(\"Work Order\", doc.work_order_ref, {\r\n            \"quality_status\": \"Completed\",\r\n            \"custom_final_item_code\": coa.final_item_code\r\n        })\r\n\r\n# Add these hooks to your existing server script\r\ndef setup_batch_history_handlers():\r\n    \"\"\"\r\n    Set up all history tracking handlers\r\n    \"\"\"\r\n    # These would be set up in your Server Script doctype, not directly in code\r\n    pass\r\n\r\n#@frappe.whitelist()\r\ndef add_manual_history_entry(batch_name, action, comments, user):\r\n    \"\"\"\r\n    Add a manual history entry to a batch\r\n    \"\"\"\r\n    batch = frappe.get_doc(\"Batch AMB\", batch_name)\r\n    \r\n    add_processing_history(\r\n        batch, \r\n        user, \r\n        action, \r\n        comments,\r\n        system_generated=False\r\n    )\r\n    \r\n    batch.save()\r\n    return True",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": null,
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:24.761391",
  "module": "amb_w_tds",
  "name": "Manual History Entries",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "#@frappe.whitelist()\r\ndef add_manual_history_entry(batch_name, action, comments, user):\r\n    \"\"\"\r\n    Add a manual history entry to a batch\r\n    \"\"\"\r\n    batch = frappe.get_doc(\"Batch AMB\", batch_name)\r\n    \r\n    add_processing_history(\r\n        batch, \r\n        user, \r\n        action, \r\n        comments,\r\n        system_generated=False\r\n    )\r\n    \r\n    batch.save()\r\n    return True",
  "script_type": "DocType Event"
 },
 {
  "allow_guest": 0,
  "api_method": "Get running batch announcements for navbar widget",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "Hourly",
  "modified": "2025-10-24 11:54:24.644446",
  "module": "amb_w_tds",
  "name": "batch_announcements_for_navbar_widget",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Batch AMB",
  "script": "import frappe\r\n\r\n@frappe.whitelist()\r\ndef get_running_batch_announcements():\r\n    \"\"\"Get running batch announcements for navbar widget\"\"\"\r\n    try:\r\n        # Check if Batch AMB doctype exists\r\n        if not frappe.db.exists(\"DocType\", \"Batch AMB\"):\r\n            return {\"success\": False, \"message\": \"Batch AMB doctype not found\"}\r\n\r\n        # Get running batches\r\n        running_batches = frappe.get_all(\"Batch AMB\", \r\n            filters={\"status\": \"Running\"}, \r\n            fields=[\"name\", \"title\", \"batch_id\", \"production_status\", \"priority\", \"start_time\"]\r\n        )\r\n\r\n        announcements = []\r\n        for batch in running_batches:\r\n            announcements.append({\r\n                \"title\": batch.title or batch.name,\r\n                \"content\": f\"🔧 Batch: {batch.batch_id or 'N/A'}\\n⏱ Status: {batch.production_status or 'Running'}\\n🕐 Started: {batch.start_time or 'N/A'}\",\r\n                \"priority\": batch.priority or \"medium\"\r\n            })\r\n\r\n        return {\r\n            \"success\": True,\r\n            \"announcements\": announcements,\r\n            \"count\": len(announcements)\r\n        }\r\n\r\n    except Exception as e:\r\n        frappe.log_error(\"Batch Announcements Error\", str(e))\r\n        return {\"success\": False, \"message\": str(e)}",
  "script_type": "API"
 },
 {
  "allow_guest": 1,
  "api_method": "/api/method/sales_order_webhook.handler",
  "cron_format": null,
  "disabled": 0,
  "docstatus": 0,
  "doctype": "Server Script",
  "doctype_event": "Before Insert",
  "enable_rate_limit": 0,
  "event_frequency": "All",
  "modified": "2025-10-24 11:54:25.155024",
  "module": "amb_w_tds",
  "name": "sales_order_webhook.handler",
  "rate_limit_count": 5,
  "rate_limit_seconds": 86400,
  "reference_doctype": "Raven Webhook Handler",
  "script": "import frappe\r\nimport hmac\r\nimport hashlib\r\n\r\n@frappe.whitelist(allow_guest=True)\r\ndef handler():\r\n    # 1. Verify the webhook secret (from Raven Webhook Handler)\r\n    webhook_config = frappe.get_doc(\"Raven Webhook Handler\", \"Sales Order Webhook\")  # Replace with your Webhook Handler name\r\n    secret = webhook_config.get_password(\"secret_key\")  # Gets the encrypted secret\r\n    \r\n    # 2. Validate HMAC signature\r\n    received_signature = frappe.get_request_header(\"X-Raven-Signature\")\r\n    payload = frappe.request.get_data(as_text=True)\r\n    \r\n    computed_signature = hmac.new(\r\n        secret.encode(\"utf-8\"),\r\n        payload.encode(\"utf-8\"),\r\n        hashlib.sha256\r\n    ).hexdigest()\r\n    \r\n    if not hmac.compare_digest(received_signature, computed_signature):\r\n        frappe.throw(\"Invalid signature\", frappe.AuthenticationError)\r\n    \r\n    # 3. Process the Sales Order data\r\n    data = frappe.parse_json(payload)\r\n    sales_order = data.get(\"doc\")  # Contains the full Sales Order data\r\n    \r\n    if sales_order.get(\"docstatus\") == 1:  # Submitted SO\r\n        # Example: Create a Project from the Sales Order\r\n        project = frappe.get_doc({\r\n            \"doctype\": \"Project\",\r\n            \"project_name\": f\"Installation - {sales_order.get('name')}\",\r\n            \"sales_order\": sales_order.get(\"name\"),\r\n            \"expected_start_date\": sales_order.get(\"delivery_date\")\r\n        }).insert()\r\n        \r\n        frappe.db.commit()\r\n        \r\n        return {\"success\": True, \"project_id\": project.name}\r\n    \r\n    return {\"success\": False, \"error\": \"Sales Order not submitted\"}",
  "script_type": "API"
 }
]